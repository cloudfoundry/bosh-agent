//go:build linux

// Code generated by counterfeiter. DO NOT EDIT.
package firewallfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-agent/v2/platform/firewall"
	"github.com/google/nftables"
)

type FakeNftablesConn struct {
	AddChainStub        func(*nftables.Chain) *nftables.Chain
	addChainMutex       sync.RWMutex
	addChainArgsForCall []struct {
		arg1 *nftables.Chain
	}
	addChainReturns struct {
		result1 *nftables.Chain
	}
	addChainReturnsOnCall map[int]struct {
		result1 *nftables.Chain
	}
	AddRuleStub        func(*nftables.Rule) *nftables.Rule
	addRuleMutex       sync.RWMutex
	addRuleArgsForCall []struct {
		arg1 *nftables.Rule
	}
	addRuleReturns struct {
		result1 *nftables.Rule
	}
	addRuleReturnsOnCall map[int]struct {
		result1 *nftables.Rule
	}
	AddTableStub        func(*nftables.Table) *nftables.Table
	addTableMutex       sync.RWMutex
	addTableArgsForCall []struct {
		arg1 *nftables.Table
	}
	addTableReturns struct {
		result1 *nftables.Table
	}
	addTableReturnsOnCall map[int]struct {
		result1 *nftables.Table
	}
	CloseLastingStub        func() error
	closeLastingMutex       sync.RWMutex
	closeLastingArgsForCall []struct {
	}
	closeLastingReturns struct {
		result1 error
	}
	closeLastingReturnsOnCall map[int]struct {
		result1 error
	}
	DelRuleStub        func(*nftables.Rule) error
	delRuleMutex       sync.RWMutex
	delRuleArgsForCall []struct {
		arg1 *nftables.Rule
	}
	delRuleReturns struct {
		result1 error
	}
	delRuleReturnsOnCall map[int]struct {
		result1 error
	}
	FlushStub        func() error
	flushMutex       sync.RWMutex
	flushArgsForCall []struct {
	}
	flushReturns struct {
		result1 error
	}
	flushReturnsOnCall map[int]struct {
		result1 error
	}
	FlushChainStub        func(*nftables.Chain)
	flushChainMutex       sync.RWMutex
	flushChainArgsForCall []struct {
		arg1 *nftables.Chain
	}
	GetRulesStub        func(*nftables.Table, *nftables.Chain) ([]*nftables.Rule, error)
	getRulesMutex       sync.RWMutex
	getRulesArgsForCall []struct {
		arg1 *nftables.Table
		arg2 *nftables.Chain
	}
	getRulesReturns struct {
		result1 []*nftables.Rule
		result2 error
	}
	getRulesReturnsOnCall map[int]struct {
		result1 []*nftables.Rule
		result2 error
	}
	ListChainsStub        func() ([]*nftables.Chain, error)
	listChainsMutex       sync.RWMutex
	listChainsArgsForCall []struct {
	}
	listChainsReturns struct {
		result1 []*nftables.Chain
		result2 error
	}
	listChainsReturnsOnCall map[int]struct {
		result1 []*nftables.Chain
		result2 error
	}
	ListTablesStub        func() ([]*nftables.Table, error)
	listTablesMutex       sync.RWMutex
	listTablesArgsForCall []struct {
	}
	listTablesReturns struct {
		result1 []*nftables.Table
		result2 error
	}
	listTablesReturnsOnCall map[int]struct {
		result1 []*nftables.Table
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNftablesConn) AddChain(arg1 *nftables.Chain) *nftables.Chain {
	fake.addChainMutex.Lock()
	ret, specificReturn := fake.addChainReturnsOnCall[len(fake.addChainArgsForCall)]
	fake.addChainArgsForCall = append(fake.addChainArgsForCall, struct {
		arg1 *nftables.Chain
	}{arg1})
	stub := fake.AddChainStub
	fakeReturns := fake.addChainReturns
	fake.recordInvocation("AddChain", []interface{}{arg1})
	fake.addChainMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) AddChainCallCount() int {
	fake.addChainMutex.RLock()
	defer fake.addChainMutex.RUnlock()
	return len(fake.addChainArgsForCall)
}

func (fake *FakeNftablesConn) AddChainCalls(stub func(*nftables.Chain) *nftables.Chain) {
	fake.addChainMutex.Lock()
	defer fake.addChainMutex.Unlock()
	fake.AddChainStub = stub
}

func (fake *FakeNftablesConn) AddChainArgsForCall(i int) *nftables.Chain {
	fake.addChainMutex.RLock()
	defer fake.addChainMutex.RUnlock()
	argsForCall := fake.addChainArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) AddChainReturns(result1 *nftables.Chain) {
	fake.addChainMutex.Lock()
	defer fake.addChainMutex.Unlock()
	fake.AddChainStub = nil
	fake.addChainReturns = struct {
		result1 *nftables.Chain
	}{result1}
}

func (fake *FakeNftablesConn) AddChainReturnsOnCall(i int, result1 *nftables.Chain) {
	fake.addChainMutex.Lock()
	defer fake.addChainMutex.Unlock()
	fake.AddChainStub = nil
	if fake.addChainReturnsOnCall == nil {
		fake.addChainReturnsOnCall = make(map[int]struct {
			result1 *nftables.Chain
		})
	}
	fake.addChainReturnsOnCall[i] = struct {
		result1 *nftables.Chain
	}{result1}
}

func (fake *FakeNftablesConn) AddRule(arg1 *nftables.Rule) *nftables.Rule {
	fake.addRuleMutex.Lock()
	ret, specificReturn := fake.addRuleReturnsOnCall[len(fake.addRuleArgsForCall)]
	fake.addRuleArgsForCall = append(fake.addRuleArgsForCall, struct {
		arg1 *nftables.Rule
	}{arg1})
	stub := fake.AddRuleStub
	fakeReturns := fake.addRuleReturns
	fake.recordInvocation("AddRule", []interface{}{arg1})
	fake.addRuleMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) AddRuleCallCount() int {
	fake.addRuleMutex.RLock()
	defer fake.addRuleMutex.RUnlock()
	return len(fake.addRuleArgsForCall)
}

func (fake *FakeNftablesConn) AddRuleCalls(stub func(*nftables.Rule) *nftables.Rule) {
	fake.addRuleMutex.Lock()
	defer fake.addRuleMutex.Unlock()
	fake.AddRuleStub = stub
}

func (fake *FakeNftablesConn) AddRuleArgsForCall(i int) *nftables.Rule {
	fake.addRuleMutex.RLock()
	defer fake.addRuleMutex.RUnlock()
	argsForCall := fake.addRuleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) AddRuleReturns(result1 *nftables.Rule) {
	fake.addRuleMutex.Lock()
	defer fake.addRuleMutex.Unlock()
	fake.AddRuleStub = nil
	fake.addRuleReturns = struct {
		result1 *nftables.Rule
	}{result1}
}

func (fake *FakeNftablesConn) AddRuleReturnsOnCall(i int, result1 *nftables.Rule) {
	fake.addRuleMutex.Lock()
	defer fake.addRuleMutex.Unlock()
	fake.AddRuleStub = nil
	if fake.addRuleReturnsOnCall == nil {
		fake.addRuleReturnsOnCall = make(map[int]struct {
			result1 *nftables.Rule
		})
	}
	fake.addRuleReturnsOnCall[i] = struct {
		result1 *nftables.Rule
	}{result1}
}

func (fake *FakeNftablesConn) AddTable(arg1 *nftables.Table) *nftables.Table {
	fake.addTableMutex.Lock()
	ret, specificReturn := fake.addTableReturnsOnCall[len(fake.addTableArgsForCall)]
	fake.addTableArgsForCall = append(fake.addTableArgsForCall, struct {
		arg1 *nftables.Table
	}{arg1})
	stub := fake.AddTableStub
	fakeReturns := fake.addTableReturns
	fake.recordInvocation("AddTable", []interface{}{arg1})
	fake.addTableMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) AddTableCallCount() int {
	fake.addTableMutex.RLock()
	defer fake.addTableMutex.RUnlock()
	return len(fake.addTableArgsForCall)
}

func (fake *FakeNftablesConn) AddTableCalls(stub func(*nftables.Table) *nftables.Table) {
	fake.addTableMutex.Lock()
	defer fake.addTableMutex.Unlock()
	fake.AddTableStub = stub
}

func (fake *FakeNftablesConn) AddTableArgsForCall(i int) *nftables.Table {
	fake.addTableMutex.RLock()
	defer fake.addTableMutex.RUnlock()
	argsForCall := fake.addTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) AddTableReturns(result1 *nftables.Table) {
	fake.addTableMutex.Lock()
	defer fake.addTableMutex.Unlock()
	fake.AddTableStub = nil
	fake.addTableReturns = struct {
		result1 *nftables.Table
	}{result1}
}

func (fake *FakeNftablesConn) AddTableReturnsOnCall(i int, result1 *nftables.Table) {
	fake.addTableMutex.Lock()
	defer fake.addTableMutex.Unlock()
	fake.AddTableStub = nil
	if fake.addTableReturnsOnCall == nil {
		fake.addTableReturnsOnCall = make(map[int]struct {
			result1 *nftables.Table
		})
	}
	fake.addTableReturnsOnCall[i] = struct {
		result1 *nftables.Table
	}{result1}
}

func (fake *FakeNftablesConn) CloseLasting() error {
	fake.closeLastingMutex.Lock()
	ret, specificReturn := fake.closeLastingReturnsOnCall[len(fake.closeLastingArgsForCall)]
	fake.closeLastingArgsForCall = append(fake.closeLastingArgsForCall, struct {
	}{})
	stub := fake.CloseLastingStub
	fakeReturns := fake.closeLastingReturns
	fake.recordInvocation("CloseLasting", []interface{}{})
	fake.closeLastingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) CloseLastingCallCount() int {
	fake.closeLastingMutex.RLock()
	defer fake.closeLastingMutex.RUnlock()
	return len(fake.closeLastingArgsForCall)
}

func (fake *FakeNftablesConn) CloseLastingCalls(stub func() error) {
	fake.closeLastingMutex.Lock()
	defer fake.closeLastingMutex.Unlock()
	fake.CloseLastingStub = stub
}

func (fake *FakeNftablesConn) CloseLastingReturns(result1 error) {
	fake.closeLastingMutex.Lock()
	defer fake.closeLastingMutex.Unlock()
	fake.CloseLastingStub = nil
	fake.closeLastingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNftablesConn) CloseLastingReturnsOnCall(i int, result1 error) {
	fake.closeLastingMutex.Lock()
	defer fake.closeLastingMutex.Unlock()
	fake.CloseLastingStub = nil
	if fake.closeLastingReturnsOnCall == nil {
		fake.closeLastingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeLastingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNftablesConn) DelRule(arg1 *nftables.Rule) error {
	fake.delRuleMutex.Lock()
	ret, specificReturn := fake.delRuleReturnsOnCall[len(fake.delRuleArgsForCall)]
	fake.delRuleArgsForCall = append(fake.delRuleArgsForCall, struct {
		arg1 *nftables.Rule
	}{arg1})
	stub := fake.DelRuleStub
	fakeReturns := fake.delRuleReturns
	fake.recordInvocation("DelRule", []interface{}{arg1})
	fake.delRuleMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) DelRuleCallCount() int {
	fake.delRuleMutex.RLock()
	defer fake.delRuleMutex.RUnlock()
	return len(fake.delRuleArgsForCall)
}

func (fake *FakeNftablesConn) DelRuleCalls(stub func(*nftables.Rule) error) {
	fake.delRuleMutex.Lock()
	defer fake.delRuleMutex.Unlock()
	fake.DelRuleStub = stub
}

func (fake *FakeNftablesConn) DelRuleArgsForCall(i int) *nftables.Rule {
	fake.delRuleMutex.RLock()
	defer fake.delRuleMutex.RUnlock()
	argsForCall := fake.delRuleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) DelRuleReturns(result1 error) {
	fake.delRuleMutex.Lock()
	defer fake.delRuleMutex.Unlock()
	fake.DelRuleStub = nil
	fake.delRuleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNftablesConn) DelRuleReturnsOnCall(i int, result1 error) {
	fake.delRuleMutex.Lock()
	defer fake.delRuleMutex.Unlock()
	fake.DelRuleStub = nil
	if fake.delRuleReturnsOnCall == nil {
		fake.delRuleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.delRuleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNftablesConn) Flush() error {
	fake.flushMutex.Lock()
	ret, specificReturn := fake.flushReturnsOnCall[len(fake.flushArgsForCall)]
	fake.flushArgsForCall = append(fake.flushArgsForCall, struct {
	}{})
	stub := fake.FlushStub
	fakeReturns := fake.flushReturns
	fake.recordInvocation("Flush", []interface{}{})
	fake.flushMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) FlushCallCount() int {
	fake.flushMutex.RLock()
	defer fake.flushMutex.RUnlock()
	return len(fake.flushArgsForCall)
}

func (fake *FakeNftablesConn) FlushCalls(stub func() error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = stub
}

func (fake *FakeNftablesConn) FlushReturns(result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	fake.flushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNftablesConn) FlushReturnsOnCall(i int, result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	if fake.flushReturnsOnCall == nil {
		fake.flushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNftablesConn) FlushChain(arg1 *nftables.Chain) {
	fake.flushChainMutex.Lock()
	fake.flushChainArgsForCall = append(fake.flushChainArgsForCall, struct {
		arg1 *nftables.Chain
	}{arg1})
	stub := fake.FlushChainStub
	fake.recordInvocation("FlushChain", []interface{}{arg1})
	fake.flushChainMutex.Unlock()
	if stub != nil {
		fake.FlushChainStub(arg1)
	}
}

func (fake *FakeNftablesConn) FlushChainCallCount() int {
	fake.flushChainMutex.RLock()
	defer fake.flushChainMutex.RUnlock()
	return len(fake.flushChainArgsForCall)
}

func (fake *FakeNftablesConn) FlushChainCalls(stub func(*nftables.Chain)) {
	fake.flushChainMutex.Lock()
	defer fake.flushChainMutex.Unlock()
	fake.FlushChainStub = stub
}

func (fake *FakeNftablesConn) FlushChainArgsForCall(i int) *nftables.Chain {
	fake.flushChainMutex.RLock()
	defer fake.flushChainMutex.RUnlock()
	argsForCall := fake.flushChainArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) GetRules(arg1 *nftables.Table, arg2 *nftables.Chain) ([]*nftables.Rule, error) {
	fake.getRulesMutex.Lock()
	ret, specificReturn := fake.getRulesReturnsOnCall[len(fake.getRulesArgsForCall)]
	fake.getRulesArgsForCall = append(fake.getRulesArgsForCall, struct {
		arg1 *nftables.Table
		arg2 *nftables.Chain
	}{arg1, arg2})
	stub := fake.GetRulesStub
	fakeReturns := fake.getRulesReturns
	fake.recordInvocation("GetRules", []interface{}{arg1, arg2})
	fake.getRulesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNftablesConn) GetRulesCallCount() int {
	fake.getRulesMutex.RLock()
	defer fake.getRulesMutex.RUnlock()
	return len(fake.getRulesArgsForCall)
}

func (fake *FakeNftablesConn) GetRulesCalls(stub func(*nftables.Table, *nftables.Chain) ([]*nftables.Rule, error)) {
	fake.getRulesMutex.Lock()
	defer fake.getRulesMutex.Unlock()
	fake.GetRulesStub = stub
}

func (fake *FakeNftablesConn) GetRulesArgsForCall(i int) (*nftables.Table, *nftables.Chain) {
	fake.getRulesMutex.RLock()
	defer fake.getRulesMutex.RUnlock()
	argsForCall := fake.getRulesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeNftablesConn) GetRulesReturns(result1 []*nftables.Rule, result2 error) {
	fake.getRulesMutex.Lock()
	defer fake.getRulesMutex.Unlock()
	fake.GetRulesStub = nil
	fake.getRulesReturns = struct {
		result1 []*nftables.Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNftablesConn) GetRulesReturnsOnCall(i int, result1 []*nftables.Rule, result2 error) {
	fake.getRulesMutex.Lock()
	defer fake.getRulesMutex.Unlock()
	fake.GetRulesStub = nil
	if fake.getRulesReturnsOnCall == nil {
		fake.getRulesReturnsOnCall = make(map[int]struct {
			result1 []*nftables.Rule
			result2 error
		})
	}
	fake.getRulesReturnsOnCall[i] = struct {
		result1 []*nftables.Rule
		result2 error
	}{result1, result2}
}

func (fake *FakeNftablesConn) ListChains() ([]*nftables.Chain, error) {
	fake.listChainsMutex.Lock()
	ret, specificReturn := fake.listChainsReturnsOnCall[len(fake.listChainsArgsForCall)]
	fake.listChainsArgsForCall = append(fake.listChainsArgsForCall, struct {
	}{})
	stub := fake.ListChainsStub
	fakeReturns := fake.listChainsReturns
	fake.recordInvocation("ListChains", []interface{}{})
	fake.listChainsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNftablesConn) ListChainsCallCount() int {
	fake.listChainsMutex.RLock()
	defer fake.listChainsMutex.RUnlock()
	return len(fake.listChainsArgsForCall)
}

func (fake *FakeNftablesConn) ListChainsCalls(stub func() ([]*nftables.Chain, error)) {
	fake.listChainsMutex.Lock()
	defer fake.listChainsMutex.Unlock()
	fake.ListChainsStub = stub
}

func (fake *FakeNftablesConn) ListChainsReturns(result1 []*nftables.Chain, result2 error) {
	fake.listChainsMutex.Lock()
	defer fake.listChainsMutex.Unlock()
	fake.ListChainsStub = nil
	fake.listChainsReturns = struct {
		result1 []*nftables.Chain
		result2 error
	}{result1, result2}
}

func (fake *FakeNftablesConn) ListChainsReturnsOnCall(i int, result1 []*nftables.Chain, result2 error) {
	fake.listChainsMutex.Lock()
	defer fake.listChainsMutex.Unlock()
	fake.ListChainsStub = nil
	if fake.listChainsReturnsOnCall == nil {
		fake.listChainsReturnsOnCall = make(map[int]struct {
			result1 []*nftables.Chain
			result2 error
		})
	}
	fake.listChainsReturnsOnCall[i] = struct {
		result1 []*nftables.Chain
		result2 error
	}{result1, result2}
}

func (fake *FakeNftablesConn) ListTables() ([]*nftables.Table, error) {
	fake.listTablesMutex.Lock()
	ret, specificReturn := fake.listTablesReturnsOnCall[len(fake.listTablesArgsForCall)]
	fake.listTablesArgsForCall = append(fake.listTablesArgsForCall, struct {
	}{})
	stub := fake.ListTablesStub
	fakeReturns := fake.listTablesReturns
	fake.recordInvocation("ListTables", []interface{}{})
	fake.listTablesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeNftablesConn) ListTablesCallCount() int {
	fake.listTablesMutex.RLock()
	defer fake.listTablesMutex.RUnlock()
	return len(fake.listTablesArgsForCall)
}

func (fake *FakeNftablesConn) ListTablesCalls(stub func() ([]*nftables.Table, error)) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = stub
}

func (fake *FakeNftablesConn) ListTablesReturns(result1 []*nftables.Table, result2 error) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = nil
	fake.listTablesReturns = struct {
		result1 []*nftables.Table
		result2 error
	}{result1, result2}
}

func (fake *FakeNftablesConn) ListTablesReturnsOnCall(i int, result1 []*nftables.Table, result2 error) {
	fake.listTablesMutex.Lock()
	defer fake.listTablesMutex.Unlock()
	fake.ListTablesStub = nil
	if fake.listTablesReturnsOnCall == nil {
		fake.listTablesReturnsOnCall = make(map[int]struct {
			result1 []*nftables.Table
			result2 error
		})
	}
	fake.listTablesReturnsOnCall[i] = struct {
		result1 []*nftables.Table
		result2 error
	}{result1, result2}
}

func (fake *FakeNftablesConn) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNftablesConn) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ firewall.NftablesConn = new(FakeNftablesConn)
