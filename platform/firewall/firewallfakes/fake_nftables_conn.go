//go:build linux

// Code generated by counterfeiter. DO NOT EDIT.
package firewallfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-agent/v2/platform/firewall"
	"github.com/google/nftables"
)

type FakeNftablesConn struct {
	AddChainStub        func(*nftables.Chain) *nftables.Chain
	addChainMutex       sync.RWMutex
	addChainArgsForCall []struct {
		arg1 *nftables.Chain
	}
	addChainReturns struct {
		result1 *nftables.Chain
	}
	addChainReturnsOnCall map[int]struct {
		result1 *nftables.Chain
	}
	AddRuleStub        func(*nftables.Rule) *nftables.Rule
	addRuleMutex       sync.RWMutex
	addRuleArgsForCall []struct {
		arg1 *nftables.Rule
	}
	addRuleReturns struct {
		result1 *nftables.Rule
	}
	addRuleReturnsOnCall map[int]struct {
		result1 *nftables.Rule
	}
	AddTableStub        func(*nftables.Table) *nftables.Table
	addTableMutex       sync.RWMutex
	addTableArgsForCall []struct {
		arg1 *nftables.Table
	}
	addTableReturns struct {
		result1 *nftables.Table
	}
	addTableReturnsOnCall map[int]struct {
		result1 *nftables.Table
	}
	DelTableStub        func(*nftables.Table)
	delTableMutex       sync.RWMutex
	delTableArgsForCall []struct {
		arg1 *nftables.Table
	}
	FlushStub        func() error
	flushMutex       sync.RWMutex
	flushArgsForCall []struct {
	}
	flushReturns struct {
		result1 error
	}
	flushReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeNftablesConn) AddChain(arg1 *nftables.Chain) *nftables.Chain {
	fake.addChainMutex.Lock()
	ret, specificReturn := fake.addChainReturnsOnCall[len(fake.addChainArgsForCall)]
	fake.addChainArgsForCall = append(fake.addChainArgsForCall, struct {
		arg1 *nftables.Chain
	}{arg1})
	stub := fake.AddChainStub
	fakeReturns := fake.addChainReturns
	fake.recordInvocation("AddChain", []interface{}{arg1})
	fake.addChainMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) AddChainCallCount() int {
	fake.addChainMutex.RLock()
	defer fake.addChainMutex.RUnlock()
	return len(fake.addChainArgsForCall)
}

func (fake *FakeNftablesConn) AddChainCalls(stub func(*nftables.Chain) *nftables.Chain) {
	fake.addChainMutex.Lock()
	defer fake.addChainMutex.Unlock()
	fake.AddChainStub = stub
}

func (fake *FakeNftablesConn) AddChainArgsForCall(i int) *nftables.Chain {
	fake.addChainMutex.RLock()
	defer fake.addChainMutex.RUnlock()
	argsForCall := fake.addChainArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) AddChainReturns(result1 *nftables.Chain) {
	fake.addChainMutex.Lock()
	defer fake.addChainMutex.Unlock()
	fake.AddChainStub = nil
	fake.addChainReturns = struct {
		result1 *nftables.Chain
	}{result1}
}

func (fake *FakeNftablesConn) AddChainReturnsOnCall(i int, result1 *nftables.Chain) {
	fake.addChainMutex.Lock()
	defer fake.addChainMutex.Unlock()
	fake.AddChainStub = nil
	if fake.addChainReturnsOnCall == nil {
		fake.addChainReturnsOnCall = make(map[int]struct {
			result1 *nftables.Chain
		})
	}
	fake.addChainReturnsOnCall[i] = struct {
		result1 *nftables.Chain
	}{result1}
}

func (fake *FakeNftablesConn) AddRule(arg1 *nftables.Rule) *nftables.Rule {
	fake.addRuleMutex.Lock()
	ret, specificReturn := fake.addRuleReturnsOnCall[len(fake.addRuleArgsForCall)]
	fake.addRuleArgsForCall = append(fake.addRuleArgsForCall, struct {
		arg1 *nftables.Rule
	}{arg1})
	stub := fake.AddRuleStub
	fakeReturns := fake.addRuleReturns
	fake.recordInvocation("AddRule", []interface{}{arg1})
	fake.addRuleMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) AddRuleCallCount() int {
	fake.addRuleMutex.RLock()
	defer fake.addRuleMutex.RUnlock()
	return len(fake.addRuleArgsForCall)
}

func (fake *FakeNftablesConn) AddRuleCalls(stub func(*nftables.Rule) *nftables.Rule) {
	fake.addRuleMutex.Lock()
	defer fake.addRuleMutex.Unlock()
	fake.AddRuleStub = stub
}

func (fake *FakeNftablesConn) AddRuleArgsForCall(i int) *nftables.Rule {
	fake.addRuleMutex.RLock()
	defer fake.addRuleMutex.RUnlock()
	argsForCall := fake.addRuleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) AddRuleReturns(result1 *nftables.Rule) {
	fake.addRuleMutex.Lock()
	defer fake.addRuleMutex.Unlock()
	fake.AddRuleStub = nil
	fake.addRuleReturns = struct {
		result1 *nftables.Rule
	}{result1}
}

func (fake *FakeNftablesConn) AddRuleReturnsOnCall(i int, result1 *nftables.Rule) {
	fake.addRuleMutex.Lock()
	defer fake.addRuleMutex.Unlock()
	fake.AddRuleStub = nil
	if fake.addRuleReturnsOnCall == nil {
		fake.addRuleReturnsOnCall = make(map[int]struct {
			result1 *nftables.Rule
		})
	}
	fake.addRuleReturnsOnCall[i] = struct {
		result1 *nftables.Rule
	}{result1}
}

func (fake *FakeNftablesConn) AddTable(arg1 *nftables.Table) *nftables.Table {
	fake.addTableMutex.Lock()
	ret, specificReturn := fake.addTableReturnsOnCall[len(fake.addTableArgsForCall)]
	fake.addTableArgsForCall = append(fake.addTableArgsForCall, struct {
		arg1 *nftables.Table
	}{arg1})
	stub := fake.AddTableStub
	fakeReturns := fake.addTableReturns
	fake.recordInvocation("AddTable", []interface{}{arg1})
	fake.addTableMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) AddTableCallCount() int {
	fake.addTableMutex.RLock()
	defer fake.addTableMutex.RUnlock()
	return len(fake.addTableArgsForCall)
}

func (fake *FakeNftablesConn) AddTableCalls(stub func(*nftables.Table) *nftables.Table) {
	fake.addTableMutex.Lock()
	defer fake.addTableMutex.Unlock()
	fake.AddTableStub = stub
}

func (fake *FakeNftablesConn) AddTableArgsForCall(i int) *nftables.Table {
	fake.addTableMutex.RLock()
	defer fake.addTableMutex.RUnlock()
	argsForCall := fake.addTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) AddTableReturns(result1 *nftables.Table) {
	fake.addTableMutex.Lock()
	defer fake.addTableMutex.Unlock()
	fake.AddTableStub = nil
	fake.addTableReturns = struct {
		result1 *nftables.Table
	}{result1}
}

func (fake *FakeNftablesConn) AddTableReturnsOnCall(i int, result1 *nftables.Table) {
	fake.addTableMutex.Lock()
	defer fake.addTableMutex.Unlock()
	fake.AddTableStub = nil
	if fake.addTableReturnsOnCall == nil {
		fake.addTableReturnsOnCall = make(map[int]struct {
			result1 *nftables.Table
		})
	}
	fake.addTableReturnsOnCall[i] = struct {
		result1 *nftables.Table
	}{result1}
}

func (fake *FakeNftablesConn) DelTable(arg1 *nftables.Table) {
	fake.delTableMutex.Lock()
	fake.delTableArgsForCall = append(fake.delTableArgsForCall, struct {
		arg1 *nftables.Table
	}{arg1})
	stub := fake.DelTableStub
	fake.recordInvocation("DelTable", []interface{}{arg1})
	fake.delTableMutex.Unlock()
	if stub != nil {
		fake.DelTableStub(arg1)
	}
}

func (fake *FakeNftablesConn) DelTableCallCount() int {
	fake.delTableMutex.RLock()
	defer fake.delTableMutex.RUnlock()
	return len(fake.delTableArgsForCall)
}

func (fake *FakeNftablesConn) DelTableCalls(stub func(*nftables.Table)) {
	fake.delTableMutex.Lock()
	defer fake.delTableMutex.Unlock()
	fake.DelTableStub = stub
}

func (fake *FakeNftablesConn) DelTableArgsForCall(i int) *nftables.Table {
	fake.delTableMutex.RLock()
	defer fake.delTableMutex.RUnlock()
	argsForCall := fake.delTableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeNftablesConn) Flush() error {
	fake.flushMutex.Lock()
	ret, specificReturn := fake.flushReturnsOnCall[len(fake.flushArgsForCall)]
	fake.flushArgsForCall = append(fake.flushArgsForCall, struct {
	}{})
	stub := fake.FlushStub
	fakeReturns := fake.flushReturns
	fake.recordInvocation("Flush", []interface{}{})
	fake.flushMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeNftablesConn) FlushCallCount() int {
	fake.flushMutex.RLock()
	defer fake.flushMutex.RUnlock()
	return len(fake.flushArgsForCall)
}

func (fake *FakeNftablesConn) FlushCalls(stub func() error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = stub
}

func (fake *FakeNftablesConn) FlushReturns(result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	fake.flushReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeNftablesConn) FlushReturnsOnCall(i int, result1 error) {
	fake.flushMutex.Lock()
	defer fake.flushMutex.Unlock()
	fake.FlushStub = nil
	if fake.flushReturnsOnCall == nil {
		fake.flushReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.flushReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeNftablesConn) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeNftablesConn) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ firewall.NftablesConn = new(FakeNftablesConn)
