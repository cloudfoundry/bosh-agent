//go:build linux

// Code generated by counterfeiter. DO NOT EDIT.
package firewallfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-agent/v2/platform/firewall"
)

type FakeCgroupResolver struct {
	DetectVersionStub        func() (firewall.CgroupVersion, error)
	detectVersionMutex       sync.RWMutex
	detectVersionArgsForCall []struct {
	}
	detectVersionReturns struct {
		result1 firewall.CgroupVersion
		result2 error
	}
	detectVersionReturnsOnCall map[int]struct {
		result1 firewall.CgroupVersion
		result2 error
	}
	GetProcessCgroupStub        func(int, firewall.CgroupVersion) (firewall.ProcessCgroup, error)
	getProcessCgroupMutex       sync.RWMutex
	getProcessCgroupArgsForCall []struct {
		arg1 int
		arg2 firewall.CgroupVersion
	}
	getProcessCgroupReturns struct {
		result1 firewall.ProcessCgroup
		result2 error
	}
	getProcessCgroupReturnsOnCall map[int]struct {
		result1 firewall.ProcessCgroup
		result2 error
	}
	IsCgroupV2SocketMatchFunctionalStub        func() bool
	isCgroupV2SocketMatchFunctionalMutex       sync.RWMutex
	isCgroupV2SocketMatchFunctionalArgsForCall []struct {
	}
	isCgroupV2SocketMatchFunctionalReturns struct {
		result1 bool
	}
	isCgroupV2SocketMatchFunctionalReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCgroupResolver) DetectVersion() (firewall.CgroupVersion, error) {
	fake.detectVersionMutex.Lock()
	ret, specificReturn := fake.detectVersionReturnsOnCall[len(fake.detectVersionArgsForCall)]
	fake.detectVersionArgsForCall = append(fake.detectVersionArgsForCall, struct {
	}{})
	stub := fake.DetectVersionStub
	fakeReturns := fake.detectVersionReturns
	fake.recordInvocation("DetectVersion", []interface{}{})
	fake.detectVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCgroupResolver) DetectVersionCallCount() int {
	fake.detectVersionMutex.RLock()
	defer fake.detectVersionMutex.RUnlock()
	return len(fake.detectVersionArgsForCall)
}

func (fake *FakeCgroupResolver) DetectVersionCalls(stub func() (firewall.CgroupVersion, error)) {
	fake.detectVersionMutex.Lock()
	defer fake.detectVersionMutex.Unlock()
	fake.DetectVersionStub = stub
}

func (fake *FakeCgroupResolver) DetectVersionReturns(result1 firewall.CgroupVersion, result2 error) {
	fake.detectVersionMutex.Lock()
	defer fake.detectVersionMutex.Unlock()
	fake.DetectVersionStub = nil
	fake.detectVersionReturns = struct {
		result1 firewall.CgroupVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) DetectVersionReturnsOnCall(i int, result1 firewall.CgroupVersion, result2 error) {
	fake.detectVersionMutex.Lock()
	defer fake.detectVersionMutex.Unlock()
	fake.DetectVersionStub = nil
	if fake.detectVersionReturnsOnCall == nil {
		fake.detectVersionReturnsOnCall = make(map[int]struct {
			result1 firewall.CgroupVersion
			result2 error
		})
	}
	fake.detectVersionReturnsOnCall[i] = struct {
		result1 firewall.CgroupVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) GetProcessCgroup(arg1 int, arg2 firewall.CgroupVersion) (firewall.ProcessCgroup, error) {
	fake.getProcessCgroupMutex.Lock()
	ret, specificReturn := fake.getProcessCgroupReturnsOnCall[len(fake.getProcessCgroupArgsForCall)]
	fake.getProcessCgroupArgsForCall = append(fake.getProcessCgroupArgsForCall, struct {
		arg1 int
		arg2 firewall.CgroupVersion
	}{arg1, arg2})
	stub := fake.GetProcessCgroupStub
	fakeReturns := fake.getProcessCgroupReturns
	fake.recordInvocation("GetProcessCgroup", []interface{}{arg1, arg2})
	fake.getProcessCgroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCgroupResolver) GetProcessCgroupCallCount() int {
	fake.getProcessCgroupMutex.RLock()
	defer fake.getProcessCgroupMutex.RUnlock()
	return len(fake.getProcessCgroupArgsForCall)
}

func (fake *FakeCgroupResolver) GetProcessCgroupCalls(stub func(int, firewall.CgroupVersion) (firewall.ProcessCgroup, error)) {
	fake.getProcessCgroupMutex.Lock()
	defer fake.getProcessCgroupMutex.Unlock()
	fake.GetProcessCgroupStub = stub
}

func (fake *FakeCgroupResolver) GetProcessCgroupArgsForCall(i int) (int, firewall.CgroupVersion) {
	fake.getProcessCgroupMutex.RLock()
	defer fake.getProcessCgroupMutex.RUnlock()
	argsForCall := fake.getProcessCgroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCgroupResolver) GetProcessCgroupReturns(result1 firewall.ProcessCgroup, result2 error) {
	fake.getProcessCgroupMutex.Lock()
	defer fake.getProcessCgroupMutex.Unlock()
	fake.GetProcessCgroupStub = nil
	fake.getProcessCgroupReturns = struct {
		result1 firewall.ProcessCgroup
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) GetProcessCgroupReturnsOnCall(i int, result1 firewall.ProcessCgroup, result2 error) {
	fake.getProcessCgroupMutex.Lock()
	defer fake.getProcessCgroupMutex.Unlock()
	fake.GetProcessCgroupStub = nil
	if fake.getProcessCgroupReturnsOnCall == nil {
		fake.getProcessCgroupReturnsOnCall = make(map[int]struct {
			result1 firewall.ProcessCgroup
			result2 error
		})
	}
	fake.getProcessCgroupReturnsOnCall[i] = struct {
		result1 firewall.ProcessCgroup
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) IsCgroupV2SocketMatchFunctional() bool {
	fake.isCgroupV2SocketMatchFunctionalMutex.Lock()
	ret, specificReturn := fake.isCgroupV2SocketMatchFunctionalReturnsOnCall[len(fake.isCgroupV2SocketMatchFunctionalArgsForCall)]
	fake.isCgroupV2SocketMatchFunctionalArgsForCall = append(fake.isCgroupV2SocketMatchFunctionalArgsForCall, struct {
	}{})
	stub := fake.IsCgroupV2SocketMatchFunctionalStub
	fakeReturns := fake.isCgroupV2SocketMatchFunctionalReturns
	fake.recordInvocation("IsCgroupV2SocketMatchFunctional", []interface{}{})
	fake.isCgroupV2SocketMatchFunctionalMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeCgroupResolver) IsCgroupV2SocketMatchFunctionalCallCount() int {
	fake.isCgroupV2SocketMatchFunctionalMutex.RLock()
	defer fake.isCgroupV2SocketMatchFunctionalMutex.RUnlock()
	return len(fake.isCgroupV2SocketMatchFunctionalArgsForCall)
}

func (fake *FakeCgroupResolver) IsCgroupV2SocketMatchFunctionalCalls(stub func() bool) {
	fake.isCgroupV2SocketMatchFunctionalMutex.Lock()
	defer fake.isCgroupV2SocketMatchFunctionalMutex.Unlock()
	fake.IsCgroupV2SocketMatchFunctionalStub = stub
}

func (fake *FakeCgroupResolver) IsCgroupV2SocketMatchFunctionalReturns(result1 bool) {
	fake.isCgroupV2SocketMatchFunctionalMutex.Lock()
	defer fake.isCgroupV2SocketMatchFunctionalMutex.Unlock()
	fake.IsCgroupV2SocketMatchFunctionalStub = nil
	fake.isCgroupV2SocketMatchFunctionalReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCgroupResolver) IsCgroupV2SocketMatchFunctionalReturnsOnCall(i int, result1 bool) {
	fake.isCgroupV2SocketMatchFunctionalMutex.Lock()
	defer fake.isCgroupV2SocketMatchFunctionalMutex.Unlock()
	fake.IsCgroupV2SocketMatchFunctionalStub = nil
	if fake.isCgroupV2SocketMatchFunctionalReturnsOnCall == nil {
		fake.isCgroupV2SocketMatchFunctionalReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isCgroupV2SocketMatchFunctionalReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeCgroupResolver) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCgroupResolver) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ firewall.CgroupResolver = new(FakeCgroupResolver)
