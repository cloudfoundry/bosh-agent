//go:build linux

// Code generated by counterfeiter. DO NOT EDIT.
package firewallfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-agent/v2/platform/firewall"
)

type FakeCgroupResolver struct {
	DetectVersionStub        func() (firewall.CgroupVersion, error)
	detectVersionMutex       sync.RWMutex
	detectVersionArgsForCall []struct {
	}
	detectVersionReturns struct {
		result1 firewall.CgroupVersion
		result2 error
	}
	detectVersionReturnsOnCall map[int]struct {
		result1 firewall.CgroupVersion
		result2 error
	}
	GetCgroupIDStub        func(string) (uint64, error)
	getCgroupIDMutex       sync.RWMutex
	getCgroupIDArgsForCall []struct {
		arg1 string
	}
	getCgroupIDReturns struct {
		result1 uint64
		result2 error
	}
	getCgroupIDReturnsOnCall map[int]struct {
		result1 uint64
		result2 error
	}
	GetProcessCgroupStub        func(int, firewall.CgroupVersion) (firewall.ProcessCgroup, error)
	getProcessCgroupMutex       sync.RWMutex
	getProcessCgroupArgsForCall []struct {
		arg1 int
		arg2 firewall.CgroupVersion
	}
	getProcessCgroupReturns struct {
		result1 firewall.ProcessCgroup
		result2 error
	}
	getProcessCgroupReturnsOnCall map[int]struct {
		result1 firewall.ProcessCgroup
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeCgroupResolver) DetectVersion() (firewall.CgroupVersion, error) {
	fake.detectVersionMutex.Lock()
	ret, specificReturn := fake.detectVersionReturnsOnCall[len(fake.detectVersionArgsForCall)]
	fake.detectVersionArgsForCall = append(fake.detectVersionArgsForCall, struct {
	}{})
	stub := fake.DetectVersionStub
	fakeReturns := fake.detectVersionReturns
	fake.recordInvocation("DetectVersion", []interface{}{})
	fake.detectVersionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCgroupResolver) DetectVersionCallCount() int {
	fake.detectVersionMutex.RLock()
	defer fake.detectVersionMutex.RUnlock()
	return len(fake.detectVersionArgsForCall)
}

func (fake *FakeCgroupResolver) DetectVersionCalls(stub func() (firewall.CgroupVersion, error)) {
	fake.detectVersionMutex.Lock()
	defer fake.detectVersionMutex.Unlock()
	fake.DetectVersionStub = stub
}

func (fake *FakeCgroupResolver) DetectVersionReturns(result1 firewall.CgroupVersion, result2 error) {
	fake.detectVersionMutex.Lock()
	defer fake.detectVersionMutex.Unlock()
	fake.DetectVersionStub = nil
	fake.detectVersionReturns = struct {
		result1 firewall.CgroupVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) DetectVersionReturnsOnCall(i int, result1 firewall.CgroupVersion, result2 error) {
	fake.detectVersionMutex.Lock()
	defer fake.detectVersionMutex.Unlock()
	fake.DetectVersionStub = nil
	if fake.detectVersionReturnsOnCall == nil {
		fake.detectVersionReturnsOnCall = make(map[int]struct {
			result1 firewall.CgroupVersion
			result2 error
		})
	}
	fake.detectVersionReturnsOnCall[i] = struct {
		result1 firewall.CgroupVersion
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) GetCgroupID(arg1 string) (uint64, error) {
	fake.getCgroupIDMutex.Lock()
	ret, specificReturn := fake.getCgroupIDReturnsOnCall[len(fake.getCgroupIDArgsForCall)]
	fake.getCgroupIDArgsForCall = append(fake.getCgroupIDArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetCgroupIDStub
	fakeReturns := fake.getCgroupIDReturns
	fake.recordInvocation("GetCgroupID", []interface{}{arg1})
	fake.getCgroupIDMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCgroupResolver) GetCgroupIDCallCount() int {
	fake.getCgroupIDMutex.RLock()
	defer fake.getCgroupIDMutex.RUnlock()
	return len(fake.getCgroupIDArgsForCall)
}

func (fake *FakeCgroupResolver) GetCgroupIDCalls(stub func(string) (uint64, error)) {
	fake.getCgroupIDMutex.Lock()
	defer fake.getCgroupIDMutex.Unlock()
	fake.GetCgroupIDStub = stub
}

func (fake *FakeCgroupResolver) GetCgroupIDArgsForCall(i int) string {
	fake.getCgroupIDMutex.RLock()
	defer fake.getCgroupIDMutex.RUnlock()
	argsForCall := fake.getCgroupIDArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeCgroupResolver) GetCgroupIDReturns(result1 uint64, result2 error) {
	fake.getCgroupIDMutex.Lock()
	defer fake.getCgroupIDMutex.Unlock()
	fake.GetCgroupIDStub = nil
	fake.getCgroupIDReturns = struct {
		result1 uint64
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) GetCgroupIDReturnsOnCall(i int, result1 uint64, result2 error) {
	fake.getCgroupIDMutex.Lock()
	defer fake.getCgroupIDMutex.Unlock()
	fake.GetCgroupIDStub = nil
	if fake.getCgroupIDReturnsOnCall == nil {
		fake.getCgroupIDReturnsOnCall = make(map[int]struct {
			result1 uint64
			result2 error
		})
	}
	fake.getCgroupIDReturnsOnCall[i] = struct {
		result1 uint64
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) GetProcessCgroup(arg1 int, arg2 firewall.CgroupVersion) (firewall.ProcessCgroup, error) {
	fake.getProcessCgroupMutex.Lock()
	ret, specificReturn := fake.getProcessCgroupReturnsOnCall[len(fake.getProcessCgroupArgsForCall)]
	fake.getProcessCgroupArgsForCall = append(fake.getProcessCgroupArgsForCall, struct {
		arg1 int
		arg2 firewall.CgroupVersion
	}{arg1, arg2})
	stub := fake.GetProcessCgroupStub
	fakeReturns := fake.getProcessCgroupReturns
	fake.recordInvocation("GetProcessCgroup", []interface{}{arg1, arg2})
	fake.getProcessCgroupMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeCgroupResolver) GetProcessCgroupCallCount() int {
	fake.getProcessCgroupMutex.RLock()
	defer fake.getProcessCgroupMutex.RUnlock()
	return len(fake.getProcessCgroupArgsForCall)
}

func (fake *FakeCgroupResolver) GetProcessCgroupCalls(stub func(int, firewall.CgroupVersion) (firewall.ProcessCgroup, error)) {
	fake.getProcessCgroupMutex.Lock()
	defer fake.getProcessCgroupMutex.Unlock()
	fake.GetProcessCgroupStub = stub
}

func (fake *FakeCgroupResolver) GetProcessCgroupArgsForCall(i int) (int, firewall.CgroupVersion) {
	fake.getProcessCgroupMutex.RLock()
	defer fake.getProcessCgroupMutex.RUnlock()
	argsForCall := fake.getProcessCgroupArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeCgroupResolver) GetProcessCgroupReturns(result1 firewall.ProcessCgroup, result2 error) {
	fake.getProcessCgroupMutex.Lock()
	defer fake.getProcessCgroupMutex.Unlock()
	fake.GetProcessCgroupStub = nil
	fake.getProcessCgroupReturns = struct {
		result1 firewall.ProcessCgroup
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) GetProcessCgroupReturnsOnCall(i int, result1 firewall.ProcessCgroup, result2 error) {
	fake.getProcessCgroupMutex.Lock()
	defer fake.getProcessCgroupMutex.Unlock()
	fake.GetProcessCgroupStub = nil
	if fake.getProcessCgroupReturnsOnCall == nil {
		fake.getProcessCgroupReturnsOnCall = make(map[int]struct {
			result1 firewall.ProcessCgroup
			result2 error
		})
	}
	fake.getProcessCgroupReturnsOnCall[i] = struct {
		result1 firewall.ProcessCgroup
		result2 error
	}{result1, result2}
}

func (fake *FakeCgroupResolver) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeCgroupResolver) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ firewall.CgroupResolver = new(FakeCgroupResolver)
