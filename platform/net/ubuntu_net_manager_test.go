package net_test

import (
	"errors"
	"strings"

	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"

	boshlog "github.com/cloudfoundry/bosh-agent/logger"
	. "github.com/cloudfoundry/bosh-agent/platform/net"
	fakearp "github.com/cloudfoundry/bosh-agent/platform/net/arp/fakes"
	fakenet "github.com/cloudfoundry/bosh-agent/platform/net/fakes"
	boship "github.com/cloudfoundry/bosh-agent/platform/net/ip"
	fakeip "github.com/cloudfoundry/bosh-agent/platform/net/ip/fakes"
	boshsettings "github.com/cloudfoundry/bosh-agent/settings"
	fakesys "github.com/cloudfoundry/bosh-agent/system/fakes"
)

var _ = Describe("ubuntuNetManager", func() {
	var (
		fs                     *fakesys.FakeFileSystem
		cmdRunner              *fakesys.FakeCmdRunner
		defaultNetworkResolver *fakenet.FakeDefaultNetworkResolver
		ipResolver             *fakeip.FakeResolver
		addressBroadcaster     *fakearp.FakeAddressBroadcaster
		netManager             Manager
	)

	BeforeEach(func() {
		fs = fakesys.NewFakeFileSystem()
		cmdRunner = fakesys.NewFakeCmdRunner()
		defaultNetworkResolver = &fakenet.FakeDefaultNetworkResolver{}
		ipResolver = &fakeip.FakeResolver{}
		addressBroadcaster = &fakearp.FakeAddressBroadcaster{}
		logger := boshlog.NewLogger(boshlog.LevelNone)
		netManager = NewUbuntuNetManager(
			fs,
			cmdRunner,
			defaultNetworkResolver,
			ipResolver,
			addressBroadcaster,
			logger,
		)
	})

	Describe("SetupDhcp", func() {
		const (
			dhcpConfPath = "/etc/dhcp/dhclient.conf"

			expectedDHCPConfig = `# Generated by bosh-agent

option rfc3442-classless-static-routes code 121 = array of unsigned integer 8;

send host-name "<hostname>";

request subnet-mask, broadcast-address, time-offset, routers,
	domain-name, domain-name-servers, domain-search, host-name,
	netbios-name-servers, netbios-scope, interface-mtu,
	rfc3442-classless-static-routes, ntp-servers;

prepend domain-name-servers xx.xx.xx.xx, yy.yy.yy.yy, zz.zz.zz.zz;
`
		)

		var (
			networks boshsettings.Networks
		)

		BeforeEach(func() {
			networks = boshsettings.Networks{
				"bosh": boshsettings.Network{
					Default: []string{"dns"},
					DNS:     []string{"xx.xx.xx.xx", "yy.yy.yy.yy", "zz.zz.zz.zz"},
				},
				"vip": boshsettings.Network{
					Default: []string{},
					DNS:     []string{"aa.aa.aa.aa"},
				},
			}
		})

		ItRestartsDhcp := func() {
			It("restarts dhclient", func() {
				err := netManager.SetupDhcp(networks, nil)
				Expect(err).ToNot(HaveOccurred())

				Expect(len(cmdRunner.RunCommands)).To(Equal(3))
				Expect(cmdRunner.RunCommands[1]).To(Equal([]string{"ifdown", "-a", "--no-loopback"}))
				Expect(cmdRunner.RunCommands[2]).To(Equal([]string{"ifup", "-a", "--no-loopback"}))
			})
		}

		ItUpdatesDhcpConfig := func(dhcpConfPath string) {
			It("writes dhcp configuration", func() {
				err := netManager.SetupDhcp(networks, nil)
				Expect(err).ToNot(HaveOccurred())

				dhcpConfig := fs.GetFileTestStat(dhcpConfPath)
				Expect(dhcpConfig).ToNot(BeNil())
				Expect(dhcpConfig.StringContents()).To(Equal(expectedDHCPConfig))
			})

			It("writes out DNS servers in order that was provided by the network because *single* DHCP prepend command is used", func() {
				err := netManager.SetupDhcp(networks, nil)
				Expect(err).ToNot(HaveOccurred())

				dhcpConfig := fs.GetFileTestStat(dhcpConfPath)
				Expect(dhcpConfig).ToNot(BeNil())
				Expect(dhcpConfig.StringContents()).To(ContainSubstring(`
prepend domain-name-servers xx.xx.xx.xx, yy.yy.yy.yy, zz.zz.zz.zz;
`))
			})

			It("does not prepend any DNS servers if network does not provide them", func() {
				net := networks["bosh"]
				net.DNS = []string{}
				networks["bosh"] = net

				err := netManager.SetupDhcp(networks, nil)
				Expect(err).ToNot(HaveOccurred())

				dhcpConfig := fs.GetFileTestStat(dhcpConfPath)
				Expect(dhcpConfig).ToNot(BeNil())
				Expect(dhcpConfig.StringContents()).ToNot(ContainSubstring(`prepend domain-name-servers`))
			})
		}

		ItDoesNotRestartDhcp := func() {
			It("does not restart dhclient", func() {
				err := netManager.SetupDhcp(networks, nil)
				Expect(err).ToNot(HaveOccurred())

				Expect(len(cmdRunner.RunCommands)).To(Equal(0))
			})
		}

		Context("when dhclient3 is not installed on the system", func() {
			BeforeEach(func() { cmdRunner.CommandExistsValue = false })

			Context("when dhcp was not previously configured", func() {
				ItUpdatesDhcpConfig(dhcpConfPath)
				ItRestartsDhcp()
			})

			Context("when dhcp was previously configured with different configuration", func() {
				BeforeEach(func() {
					fs.WriteFileString(dhcpConfPath, "fake-other-configuration")
				})

				ItUpdatesDhcpConfig(dhcpConfPath)
				ItRestartsDhcp()
			})

			Context("when dhcp was previously configured with the same configuration", func() {
				BeforeEach(func() {
					fs.WriteFileString(dhcpConfPath, expectedDHCPConfig)
				})

				ItUpdatesDhcpConfig(dhcpConfPath)
				ItDoesNotRestartDhcp()
			})

			Context("when we have one eth interface on the system", func() {
				BeforeEach(func() {
					fs.WriteFile("/etc/network/interfaces", []byte{})
					fs.WriteFile("/sys/class/net/eth0", []byte{})
					fs.WriteFileString("/sys/class/net/eth0/device", "00000000000000\n")
					fs.SetGlob("/sys/class/net/*", []string{"/sys/class/net/eth0"})
				})

				It("should have one eth interface on networks", func() {
					expectedUbuntuDhcpNetworkOneInterfaces := `# Generated by bosh-agent
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
`
					err := netManager.SetupDhcp(networks, nil)
					Expect(err).ToNot(HaveOccurred())
					networkConfig := fs.GetFileTestStat("/etc/network/interfaces")
					Expect(networkConfig).ToNot(BeNil())
					Expect(networkConfig.StringContents()).To(Equal(expectedUbuntuDhcpNetworkOneInterfaces))
				})
			})

			Context("when we have two eth interface on the system", func() {
				BeforeEach(func() {
					fs.WriteFile("/etc/network/interfaces", []byte{})
					fs.WriteFile("/sys/class/net/eth1", []byte{})
					fs.WriteFileString("/sys/class/net/eth1/device", "00000000000000\n")
					fs.WriteFile("/sys/class/net/eth2", []byte{})
					fs.WriteFileString("/sys/class/net/eth2/device", "00000000000000\n")
					fs.SetGlob("/sys/class/net/*", []string{"/sys/class/net/eth1", "/sys/class/net/eth2"})
				})

				It("should have two eth interface on networks", func() {
					expectedUbuntuDhcpNetworkTwoInterfaces := `# Generated by bosh-agent
auto lo
iface lo inet loopback

auto eth1
iface eth1 inet dhcp

auto eth2
iface eth2 inet dhcp
`
					err := netManager.SetupDhcp(networks, nil)
					Expect(err).ToNot(HaveOccurred())
					networkConfig := fs.GetFileTestStat("/etc/network/interfaces")
					Expect(networkConfig).ToNot(BeNil())
					Expect(networkConfig.StringContents()).To(Equal(expectedUbuntuDhcpNetworkTwoInterfaces))
				})
			})

			Context("when we have one eth interface  and one virtual interface on the system", func() {
				BeforeEach(func() {
					fs.WriteFile("/etc/network/interfaces", []byte{})
					fs.WriteFile("/sys/class/net/eth0", []byte{})
					fs.WriteFileString("/sys/class/net/eth0/device", "00000000000000\n")
					fs.WriteFile("/sys/class/net/eth1", []byte{})
					fs.SetGlob("/sys/class/net/*", []string{"/sys/class/net/eth0", "/sys/class/net/eth1"})
				})

				It("should have only one interface on networks", func() {
					expectedUbuntuDhcpNetworkOneInterfaces := `# Generated by bosh-agent
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet dhcp
`
					err := netManager.SetupDhcp(networks, nil)
					Expect(err).ToNot(HaveOccurred())
					networkConfig := fs.GetFileTestStat("/etc/network/interfaces")
					Expect(networkConfig).ToNot(BeNil())
					Expect(networkConfig.StringContents()).To(Equal(expectedUbuntuDhcpNetworkOneInterfaces))
				})
			})

			Context("when we have two virtual interface on the system", func() {
				BeforeEach(func() {
					fs.WriteFile("/etc/network/interfaces", []byte{})
					fs.WriteFile("/sys/class/net/eth1", []byte{})
					fs.WriteFile("/sys/class/net/eth2", []byte{})
					fs.SetGlob("/sys/class/net/*", []string{"/sys/class/net/eth1", "/sys/class/net/eth2"})
				})

				It("should have none interface on networks", func() {
					expectedUbuntuDhcpNetworkNonInterfaces := `# Generated by bosh-agent
auto lo
iface lo inet loopback
`
					err := netManager.SetupDhcp(networks, nil)
					Expect(err).ToNot(HaveOccurred())
					networkConfig := fs.GetFileTestStat("/etc/network/interfaces")
					Expect(networkConfig).ToNot(BeNil())
					Expect(networkConfig.StringContents()).To(Equal(expectedUbuntuDhcpNetworkNonInterfaces))
				})
			})

			Context("when we some error on glob /sys/class/net/ on the system", func() {
				It("returns error from glob /sys/class/net/", func() {
					fs.GlobErr = errors.New("fs-glob-error")
					err := netManager.SetupDhcp(networks, nil)
					Expect(err).To(HaveOccurred())
					Expect(err.Error()).To(ContainSubstring("fs-glob-error"))
				})
			})

			Context("when we some error on writing to /etc/network/interfaces on the system", func() {
				It("returns error from writing to /etc/network/interfaces", func() {
					fs.WriteToFileError = errors.New("fs-write-file-error")
					err := netManager.SetupDhcp(networks, nil)
					Expect(err).To(HaveOccurred())
					Expect(err.Error()).To(ContainSubstring("fs-write-file-error"))
				})
			})
		})
	})

	Describe("SetupManualNetworking", func() {
		const (
			expectedNetworkInterfaces = `# Generated by bosh-agent
auto lo
iface lo inet loopback

auto eth0
iface eth0 inet static
    address 192.168.195.6
    network 192.168.195.0
    netmask 255.255.255.0
    broadcast 192.168.195.255
    gateway 192.168.195.1
dns-nameservers 10.80.130.2 10.80.130.1`

			expectedResolvConf = `# Generated by bosh-agent
nameserver 10.80.130.2
nameserver 10.80.130.1
`
		)
		var (
			errCh chan error
		)

		BeforeEach(func() {
			errCh = make(chan error)
		})

		BeforeEach(func() {
			// For mac addr to interface resolution
			fs.WriteFile("/sys/class/net/eth0", []byte{})
			fs.WriteFileString("/sys/class/net/eth0/address", "22:00:0a:1f:ac:2a\n")
			fs.SetGlob("/sys/class/net/*", []string{"/sys/class/net/eth0"})
			fs.WriteFileString("/etc/lsb-release", "DISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=14.04")
		})

		networks := boshsettings.Networks{
			"bosh": boshsettings.Network{
				Default: []string{"dns", "gateway"},
				IP:      "192.168.195.6",
				Netmask: "255.255.255.0",
				Gateway: "192.168.195.1",
				Mac:     "22:00:0a:1f:ac:2a",
				DNS:     []string{"10.80.130.2", "10.80.130.1"},
			},
		}

		ItWritesNetworkIntefaces := func() {
			BeforeEach(func() {
				fs.WriteFileString("/etc/lsb-release", "DISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=14.04")
			})

			It("writes DNS servers in /etc/network/interfaces", func() {
				err := netManager.SetupManualNetworking(networks, nil)
				Expect(err).ToNot(HaveOccurred())

				networkConfig := fs.GetFileTestStat("/etc/network/interfaces")
				Expect(networkConfig).ToNot(BeNil())
				Expect(networkConfig.StringContents()).To(Equal(expectedNetworkInterfaces))
			})

			Context("when there are multiple networks", func() {
				BeforeEach(func() {
					fs.WriteFile("/sys/class/net/eth1", []byte{})
					fs.WriteFileString("/sys/class/net/eth1/address", "22:00:0a:1f:ac:2b\n")
					fs.SetGlob("/sys/class/net/*", []string{"/sys/class/net/eth0", "/sys/class/net/eth1"})
				})
				Context("when one network's gateway is the default gateway", func() {

					multipleNetworks := boshsettings.Networks{
						"bosh": boshsettings.Network{
							Default: []string{"dns", "gateway"},
							IP:      "192.168.195.6",
							Netmask: "255.255.255.0",
							Gateway: "192.168.195.1",
							Mac:     "22:00:0a:1f:ac:2a",
							DNS:     []string{"10.80.130.2", "10.80.130.1"},
						},
						"bosh2": boshsettings.Network{
							IP:      "192.168.196.6",
							Netmask: "255.255.255.0",
							Mac:     "22:00:0a:1f:ac:2b",
						}}
					It("includes only one gateway", func() {
						err := netManager.SetupManualNetworking(multipleNetworks, nil)
						Expect(err).ToNot(HaveOccurred())

						networkConfig := fs.GetFileTestStat("/etc/network/interfaces")
						Expect(networkConfig).ToNot(BeNil())
						Expect(networkConfig.StringContents()).To(ContainSubstring("gateway 192.168.195.1"))
						Expect(strings.Count(networkConfig.StringContents(), "gateway")).To(Equal(1))
					})
				})

				Context("when there are multiple networks but no default gateway", func() {

					multipleNetworks := boshsettings.Networks{
						"bosh": boshsettings.Network{
							Default: []string{"dns"},
							IP:      "192.168.195.6",
							Netmask: "255.255.255.0",
							Gateway: "192.168.195.1",
							Mac:     "22:00:0a:1f:ac:2a",
							DNS:     []string{"10.80.130.2", "10.80.130.1"},
						},
						"bosh2": boshsettings.Network{
							IP:      "192.168.196.6",
							Netmask: "255.255.255.0",
							Mac:     "22:00:0a:1f:ac:2b",
						}}

					It("returns error", func() {
						err := netManager.SetupManualNetworking(multipleNetworks, nil)
						Expect(err).To(HaveOccurred())
						Expect(err.Error()).To(ContainSubstring("Finding network for default gateway"))
					})
				})
			})
		}

		ItUpdatesResolvConf := func() {
			BeforeEach(func() {
				fs.WriteFileString("/etc/lsb-release", "DISTRIB_ID=Ubuntu\nDISTRIB_RELEASE=14.04")
			})

			It("does not update /etc/resolv.conf", func() {
				fs.WriteFileString("/etc/resolv.conf", "fake-resolv-conf")
				err := netManager.SetupManualNetworking(networks, nil)
				Expect(err).ToNot(HaveOccurred())

				resolvConf := fs.GetFileTestStat("/etc/resolv.conf")
				Expect(resolvConf).ToNot(BeNil())
				Expect(resolvConf.StringContents()).To(ContainSubstring("fake-resolv-conf"))
			})
		}

		ItBroadcastsMACAddress := func() {
			It("starts broadcasting the MAC addresses", func() {
				err := netManager.SetupManualNetworking(networks, errCh)
				Expect(err).ToNot(HaveOccurred())

				<-errCh // wait for all arpings

				Expect(addressBroadcaster.BroadcastMACAddressesAddresses).To(Equal([]boship.InterfaceAddress{
					boship.NewSimpleInterfaceAddress("eth0", "192.168.195.6"),
				}))
			})
		}

		Context("when manual networking was not previously configured", func() {
			ItWritesNetworkIntefaces()
			ItUpdatesResolvConf()

			It("restarts networking", func() {
				err := netManager.SetupManualNetworking(networks, errCh)
				Expect(err).ToNot(HaveOccurred())

				<-errCh // wait for all arpings

				Expect(len(cmdRunner.RunCommands) >= 2).To(BeTrue())
				Expect(cmdRunner.RunCommands[0]).To(Equal([]string{"service", "network-interface", "stop", "INTERFACE=eth0"}))
				Expect(cmdRunner.RunCommands[1]).To(Equal([]string{"service", "network-interface", "start", "INTERFACE=eth0"}))
			})

			ItBroadcastsMACAddress()
		})

		Context("when manual networking was previously configured with different configuration", func() {
			BeforeEach(func() {
				fs.WriteFileString("/etc/network/interfaces", "fake-manual-config")
			})

			ItWritesNetworkIntefaces()
			ItUpdatesResolvConf()

			It("restarts networking", func() {
				err := netManager.SetupManualNetworking(networks, errCh)
				Expect(err).ToNot(HaveOccurred())

				<-errCh // wait for all arpings

				Expect(len(cmdRunner.RunCommands) >= 2).To(BeTrue())
				Expect(cmdRunner.RunCommands[0]).To(Equal([]string{"service", "network-interface", "stop", "INTERFACE=eth0"}))
				Expect(cmdRunner.RunCommands[1]).To(Equal([]string{"service", "network-interface", "start", "INTERFACE=eth0"}))
			})

			ItBroadcastsMACAddress()
		})

		Context("when manual networking was previously configured with same configuration", func() {
			BeforeEach(func() {
				fs.WriteFileString("/etc/network/interfaces", expectedNetworkInterfaces)
			})

			ItWritesNetworkIntefaces()
			ItUpdatesResolvConf()

			It("does not restart networking because configuration did not change", func() {
				err := netManager.SetupManualNetworking(networks, errCh)
				Expect(err).ToNot(HaveOccurred())

				<-errCh // wait for all arpings

				for _, cmd := range cmdRunner.RunCommands {
					Expect(cmd[0]).ToNot(Equal("service"))
				}
			})

			ItBroadcastsMACAddress()
		})
	})
})
