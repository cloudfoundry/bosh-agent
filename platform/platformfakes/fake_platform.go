// Code generated by counterfeiter. DO NOT EDIT.
package platformfakes

import (
	"sync"

	"github.com/cloudfoundry/bosh-agent/infrastructure/devicepathresolver"
	"github.com/cloudfoundry/bosh-agent/platform"
	"github.com/cloudfoundry/bosh-agent/platform/cert"
	"github.com/cloudfoundry/bosh-agent/platform/vitals"
	"github.com/cloudfoundry/bosh-agent/settings"
	"github.com/cloudfoundry/bosh-agent/settings/directories"
	"github.com/cloudfoundry/bosh-utils/fileutil"
	"github.com/cloudfoundry/bosh-utils/system"
)

type FakePlatform struct {
	AddUserToGroupsStub        func(string, []string) error
	addUserToGroupsMutex       sync.RWMutex
	addUserToGroupsArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	addUserToGroupsReturns struct {
		result1 error
	}
	addUserToGroupsReturnsOnCall map[int]struct {
		result1 error
	}
	AdjustPersistentDiskPartitioningStub        func(settings.DiskSettings, string) error
	adjustPersistentDiskPartitioningMutex       sync.RWMutex
	adjustPersistentDiskPartitioningArgsForCall []struct {
		arg1 settings.DiskSettings
		arg2 string
	}
	adjustPersistentDiskPartitioningReturns struct {
		result1 error
	}
	adjustPersistentDiskPartitioningReturnsOnCall map[int]struct {
		result1 error
	}
	AssociateDiskStub        func(string, settings.DiskSettings) error
	associateDiskMutex       sync.RWMutex
	associateDiskArgsForCall []struct {
		arg1 string
		arg2 settings.DiskSettings
	}
	associateDiskReturns struct {
		result1 error
	}
	associateDiskReturnsOnCall map[int]struct {
		result1 error
	}
	CreateUserStub        func(string, string) error
	createUserMutex       sync.RWMutex
	createUserArgsForCall []struct {
		arg1 string
		arg2 string
	}
	createUserReturns struct {
		result1 error
	}
	createUserReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteARPEntryWithIPStub        func(string) error
	deleteARPEntryWithIPMutex       sync.RWMutex
	deleteARPEntryWithIPArgsForCall []struct {
		arg1 string
	}
	deleteARPEntryWithIPReturns struct {
		result1 error
	}
	deleteARPEntryWithIPReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteEphemeralUsersMatchingStub        func(string) error
	deleteEphemeralUsersMatchingMutex       sync.RWMutex
	deleteEphemeralUsersMatchingArgsForCall []struct {
		arg1 string
	}
	deleteEphemeralUsersMatchingReturns struct {
		result1 error
	}
	deleteEphemeralUsersMatchingReturnsOnCall map[int]struct {
		result1 error
	}
	GetAgentSettingsPathStub        func(bool) string
	getAgentSettingsPathMutex       sync.RWMutex
	getAgentSettingsPathArgsForCall []struct {
		arg1 bool
	}
	getAgentSettingsPathReturns struct {
		result1 string
	}
	getAgentSettingsPathReturnsOnCall map[int]struct {
		result1 string
	}
	GetAuditLoggerStub        func() platform.AuditLogger
	getAuditLoggerMutex       sync.RWMutex
	getAuditLoggerArgsForCall []struct {
	}
	getAuditLoggerReturns struct {
		result1 platform.AuditLogger
	}
	getAuditLoggerReturnsOnCall map[int]struct {
		result1 platform.AuditLogger
	}
	GetCertManagerStub        func() cert.Manager
	getCertManagerMutex       sync.RWMutex
	getCertManagerArgsForCall []struct {
	}
	getCertManagerReturns struct {
		result1 cert.Manager
	}
	getCertManagerReturnsOnCall map[int]struct {
		result1 cert.Manager
	}
	GetCompressorStub        func() fileutil.Compressor
	getCompressorMutex       sync.RWMutex
	getCompressorArgsForCall []struct {
	}
	getCompressorReturns struct {
		result1 fileutil.Compressor
	}
	getCompressorReturnsOnCall map[int]struct {
		result1 fileutil.Compressor
	}
	GetConfiguredNetworkInterfacesStub        func() ([]string, error)
	getConfiguredNetworkInterfacesMutex       sync.RWMutex
	getConfiguredNetworkInterfacesArgsForCall []struct {
	}
	getConfiguredNetworkInterfacesReturns struct {
		result1 []string
		result2 error
	}
	getConfiguredNetworkInterfacesReturnsOnCall map[int]struct {
		result1 []string
		result2 error
	}
	GetCopierStub        func() fileutil.Copier
	getCopierMutex       sync.RWMutex
	getCopierArgsForCall []struct {
	}
	getCopierReturns struct {
		result1 fileutil.Copier
	}
	getCopierReturnsOnCall map[int]struct {
		result1 fileutil.Copier
	}
	GetDefaultNetworkStub        func() (settings.Network, error)
	getDefaultNetworkMutex       sync.RWMutex
	getDefaultNetworkArgsForCall []struct {
	}
	getDefaultNetworkReturns struct {
		result1 settings.Network
		result2 error
	}
	getDefaultNetworkReturnsOnCall map[int]struct {
		result1 settings.Network
		result2 error
	}
	GetDevicePathResolverStub        func() devicepathresolver.DevicePathResolver
	getDevicePathResolverMutex       sync.RWMutex
	getDevicePathResolverArgsForCall []struct {
	}
	getDevicePathResolverReturns struct {
		result1 devicepathresolver.DevicePathResolver
	}
	getDevicePathResolverReturnsOnCall map[int]struct {
		result1 devicepathresolver.DevicePathResolver
	}
	GetDirProviderStub        func() directories.Provider
	getDirProviderMutex       sync.RWMutex
	getDirProviderArgsForCall []struct {
	}
	getDirProviderReturns struct {
		result1 directories.Provider
	}
	getDirProviderReturnsOnCall map[int]struct {
		result1 directories.Provider
	}
	GetEphemeralDiskPathStub        func(settings.DiskSettings) (string, error)
	getEphemeralDiskPathMutex       sync.RWMutex
	getEphemeralDiskPathArgsForCall []struct {
		arg1 settings.DiskSettings
	}
	getEphemeralDiskPathReturns struct {
		result1 string
		result2 error
	}
	getEphemeralDiskPathReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetFileContentsFromCDROMStub        func(string) ([]byte, error)
	getFileContentsFromCDROMMutex       sync.RWMutex
	getFileContentsFromCDROMArgsForCall []struct {
		arg1 string
	}
	getFileContentsFromCDROMReturns struct {
		result1 []byte
		result2 error
	}
	getFileContentsFromCDROMReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	GetFilesContentsFromDiskStub        func(string, []string) ([][]byte, error)
	getFilesContentsFromDiskMutex       sync.RWMutex
	getFilesContentsFromDiskArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	getFilesContentsFromDiskReturns struct {
		result1 [][]byte
		result2 error
	}
	getFilesContentsFromDiskReturnsOnCall map[int]struct {
		result1 [][]byte
		result2 error
	}
	GetFsStub        func() system.FileSystem
	getFsMutex       sync.RWMutex
	getFsArgsForCall []struct {
	}
	getFsReturns struct {
		result1 system.FileSystem
	}
	getFsReturnsOnCall map[int]struct {
		result1 system.FileSystem
	}
	GetHostPublicKeyStub        func() (string, error)
	getHostPublicKeyMutex       sync.RWMutex
	getHostPublicKeyArgsForCall []struct {
	}
	getHostPublicKeyReturns struct {
		result1 string
		result2 error
	}
	getHostPublicKeyReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetMonitCredentialsStub        func() (string, string, error)
	getMonitCredentialsMutex       sync.RWMutex
	getMonitCredentialsArgsForCall []struct {
	}
	getMonitCredentialsReturns struct {
		result1 string
		result2 string
		result3 error
	}
	getMonitCredentialsReturnsOnCall map[int]struct {
		result1 string
		result2 string
		result3 error
	}
	GetPersistentDiskSettingsPathStub        func(bool) string
	getPersistentDiskSettingsPathMutex       sync.RWMutex
	getPersistentDiskSettingsPathArgsForCall []struct {
		arg1 bool
	}
	getPersistentDiskSettingsPathReturns struct {
		result1 string
	}
	getPersistentDiskSettingsPathReturnsOnCall map[int]struct {
		result1 string
	}
	GetRunnerStub        func() system.CmdRunner
	getRunnerMutex       sync.RWMutex
	getRunnerArgsForCall []struct {
	}
	getRunnerReturns struct {
		result1 system.CmdRunner
	}
	getRunnerReturnsOnCall map[int]struct {
		result1 system.CmdRunner
	}
	GetUpdateSettingsPathStub        func(bool) string
	getUpdateSettingsPathMutex       sync.RWMutex
	getUpdateSettingsPathArgsForCall []struct {
		arg1 bool
	}
	getUpdateSettingsPathReturns struct {
		result1 string
	}
	getUpdateSettingsPathReturnsOnCall map[int]struct {
		result1 string
	}
	GetVitalsServiceStub        func() vitals.Service
	getVitalsServiceMutex       sync.RWMutex
	getVitalsServiceArgsForCall []struct {
	}
	getVitalsServiceReturns struct {
		result1 vitals.Service
	}
	getVitalsServiceReturnsOnCall map[int]struct {
		result1 vitals.Service
	}
	IsMountPointStub        func(string) (string, bool, error)
	isMountPointMutex       sync.RWMutex
	isMountPointArgsForCall []struct {
		arg1 string
	}
	isMountPointReturns struct {
		result1 string
		result2 bool
		result3 error
	}
	isMountPointReturnsOnCall map[int]struct {
		result1 string
		result2 bool
		result3 error
	}
	IsPersistentDiskMountableStub        func(settings.DiskSettings) (bool, error)
	isPersistentDiskMountableMutex       sync.RWMutex
	isPersistentDiskMountableArgsForCall []struct {
		arg1 settings.DiskSettings
	}
	isPersistentDiskMountableReturns struct {
		result1 bool
		result2 error
	}
	isPersistentDiskMountableReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	IsPersistentDiskMountedStub        func(settings.DiskSettings) (bool, error)
	isPersistentDiskMountedMutex       sync.RWMutex
	isPersistentDiskMountedArgsForCall []struct {
		arg1 settings.DiskSettings
	}
	isPersistentDiskMountedReturns struct {
		result1 bool
		result2 error
	}
	isPersistentDiskMountedReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	MigratePersistentDiskStub        func(string, string) error
	migratePersistentDiskMutex       sync.RWMutex
	migratePersistentDiskArgsForCall []struct {
		arg1 string
		arg2 string
	}
	migratePersistentDiskReturns struct {
		result1 error
	}
	migratePersistentDiskReturnsOnCall map[int]struct {
		result1 error
	}
	MountPersistentDiskStub        func(settings.DiskSettings, string) error
	mountPersistentDiskMutex       sync.RWMutex
	mountPersistentDiskArgsForCall []struct {
		arg1 settings.DiskSettings
		arg2 string
	}
	mountPersistentDiskReturns struct {
		result1 error
	}
	mountPersistentDiskReturnsOnCall map[int]struct {
		result1 error
	}
	PrepareForNetworkingChangeStub        func() error
	prepareForNetworkingChangeMutex       sync.RWMutex
	prepareForNetworkingChangeArgsForCall []struct {
	}
	prepareForNetworkingChangeReturns struct {
		result1 error
	}
	prepareForNetworkingChangeReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveDevToolsStub        func(string) error
	removeDevToolsMutex       sync.RWMutex
	removeDevToolsArgsForCall []struct {
		arg1 string
	}
	removeDevToolsReturns struct {
		result1 error
	}
	removeDevToolsReturnsOnCall map[int]struct {
		result1 error
	}
	RemoveStaticLibrariesStub        func(string) error
	removeStaticLibrariesMutex       sync.RWMutex
	removeStaticLibrariesArgsForCall []struct {
		arg1 string
	}
	removeStaticLibrariesReturns struct {
		result1 error
	}
	removeStaticLibrariesReturnsOnCall map[int]struct {
		result1 error
	}
	SaveDNSRecordsStub        func(settings.DNSRecords, string) error
	saveDNSRecordsMutex       sync.RWMutex
	saveDNSRecordsArgsForCall []struct {
		arg1 settings.DNSRecords
		arg2 string
	}
	saveDNSRecordsReturns struct {
		result1 error
	}
	saveDNSRecordsReturnsOnCall map[int]struct {
		result1 error
	}
	SetTimeWithNtpServersStub        func([]string) error
	setTimeWithNtpServersMutex       sync.RWMutex
	setTimeWithNtpServersArgsForCall []struct {
		arg1 []string
	}
	setTimeWithNtpServersReturns struct {
		result1 error
	}
	setTimeWithNtpServersReturnsOnCall map[int]struct {
		result1 error
	}
	SetUserPasswordStub        func(string, string) error
	setUserPasswordMutex       sync.RWMutex
	setUserPasswordArgsForCall []struct {
		arg1 string
		arg2 string
	}
	setUserPasswordReturns struct {
		result1 error
	}
	setUserPasswordReturnsOnCall map[int]struct {
		result1 error
	}
	SetupBlobsDirStub        func() error
	setupBlobsDirMutex       sync.RWMutex
	setupBlobsDirArgsForCall []struct {
	}
	setupBlobsDirReturns struct {
		result1 error
	}
	setupBlobsDirReturnsOnCall map[int]struct {
		result1 error
	}
	SetupBoshSettingsDiskStub        func() error
	setupBoshSettingsDiskMutex       sync.RWMutex
	setupBoshSettingsDiskArgsForCall []struct {
	}
	setupBoshSettingsDiskReturns struct {
		result1 error
	}
	setupBoshSettingsDiskReturnsOnCall map[int]struct {
		result1 error
	}
	SetupCanRestartDirStub        func() error
	setupCanRestartDirMutex       sync.RWMutex
	setupCanRestartDirArgsForCall []struct {
	}
	setupCanRestartDirReturns struct {
		result1 error
	}
	setupCanRestartDirReturnsOnCall map[int]struct {
		result1 error
	}
	SetupDataDirStub        func(settings.JobDir, settings.RunDir) error
	setupDataDirMutex       sync.RWMutex
	setupDataDirArgsForCall []struct {
		arg1 settings.JobDir
		arg2 settings.RunDir
	}
	setupDataDirReturns struct {
		result1 error
	}
	setupDataDirReturnsOnCall map[int]struct {
		result1 error
	}
	SetupEphemeralDiskWithPathStub        func(string, *uint64, string) error
	setupEphemeralDiskWithPathMutex       sync.RWMutex
	setupEphemeralDiskWithPathArgsForCall []struct {
		arg1 string
		arg2 *uint64
		arg3 string
	}
	setupEphemeralDiskWithPathReturns struct {
		result1 error
	}
	setupEphemeralDiskWithPathReturnsOnCall map[int]struct {
		result1 error
	}
	SetupHomeDirStub        func() error
	setupHomeDirMutex       sync.RWMutex
	setupHomeDirArgsForCall []struct {
	}
	setupHomeDirReturns struct {
		result1 error
	}
	setupHomeDirReturnsOnCall map[int]struct {
		result1 error
	}
	SetupHostnameStub        func(string) error
	setupHostnameMutex       sync.RWMutex
	setupHostnameArgsForCall []struct {
		arg1 string
	}
	setupHostnameReturns struct {
		result1 error
	}
	setupHostnameReturnsOnCall map[int]struct {
		result1 error
	}
	SetupIPv6Stub        func(settings.IPv6) error
	setupIPv6Mutex       sync.RWMutex
	setupIPv6ArgsForCall []struct {
		arg1 settings.IPv6
	}
	setupIPv6Returns struct {
		result1 error
	}
	setupIPv6ReturnsOnCall map[int]struct {
		result1 error
	}
	SetupLogDirStub        func() error
	setupLogDirMutex       sync.RWMutex
	setupLogDirArgsForCall []struct {
	}
	setupLogDirReturns struct {
		result1 error
	}
	setupLogDirReturnsOnCall map[int]struct {
		result1 error
	}
	SetupLoggingAndAuditingStub        func() error
	setupLoggingAndAuditingMutex       sync.RWMutex
	setupLoggingAndAuditingArgsForCall []struct {
	}
	setupLoggingAndAuditingReturns struct {
		result1 error
	}
	setupLoggingAndAuditingReturnsOnCall map[int]struct {
		result1 error
	}
	SetupLogrotateStub        func(string, string, string) error
	setupLogrotateMutex       sync.RWMutex
	setupLogrotateArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 string
	}
	setupLogrotateReturns struct {
		result1 error
	}
	setupLogrotateReturnsOnCall map[int]struct {
		result1 error
	}
	SetupMonitUserStub        func() error
	setupMonitUserMutex       sync.RWMutex
	setupMonitUserArgsForCall []struct {
	}
	setupMonitUserReturns struct {
		result1 error
	}
	setupMonitUserReturnsOnCall map[int]struct {
		result1 error
	}
	SetupNetworkingStub        func(settings.Networks, string) error
	setupNetworkingMutex       sync.RWMutex
	setupNetworkingArgsForCall []struct {
		arg1 settings.Networks
		arg2 string
	}
	setupNetworkingReturns struct {
		result1 error
	}
	setupNetworkingReturnsOnCall map[int]struct {
		result1 error
	}
	SetupOptDirStub        func() error
	setupOptDirMutex       sync.RWMutex
	setupOptDirArgsForCall []struct {
	}
	setupOptDirReturns struct {
		result1 error
	}
	setupOptDirReturnsOnCall map[int]struct {
		result1 error
	}
	SetupRawEphemeralDisksStub        func([]settings.DiskSettings) error
	setupRawEphemeralDisksMutex       sync.RWMutex
	setupRawEphemeralDisksArgsForCall []struct {
		arg1 []settings.DiskSettings
	}
	setupRawEphemeralDisksReturns struct {
		result1 error
	}
	setupRawEphemeralDisksReturnsOnCall map[int]struct {
		result1 error
	}
	SetupRecordsJSONPermissionStub        func(string) error
	setupRecordsJSONPermissionMutex       sync.RWMutex
	setupRecordsJSONPermissionArgsForCall []struct {
		arg1 string
	}
	setupRecordsJSONPermissionReturns struct {
		result1 error
	}
	setupRecordsJSONPermissionReturnsOnCall map[int]struct {
		result1 error
	}
	SetupRootDiskStub        func(string) error
	setupRootDiskMutex       sync.RWMutex
	setupRootDiskArgsForCall []struct {
		arg1 string
	}
	setupRootDiskReturns struct {
		result1 error
	}
	setupRootDiskReturnsOnCall map[int]struct {
		result1 error
	}
	SetupRuntimeConfigurationStub        func() error
	setupRuntimeConfigurationMutex       sync.RWMutex
	setupRuntimeConfigurationArgsForCall []struct {
	}
	setupRuntimeConfigurationReturns struct {
		result1 error
	}
	setupRuntimeConfigurationReturnsOnCall map[int]struct {
		result1 error
	}
	SetupSSHStub        func([]string, string) error
	setupSSHMutex       sync.RWMutex
	setupSSHArgsForCall []struct {
		arg1 []string
		arg2 string
	}
	setupSSHReturns struct {
		result1 error
	}
	setupSSHReturnsOnCall map[int]struct {
		result1 error
	}
	SetupSharedMemoryStub        func() error
	setupSharedMemoryMutex       sync.RWMutex
	setupSharedMemoryArgsForCall []struct {
	}
	setupSharedMemoryReturns struct {
		result1 error
	}
	setupSharedMemoryReturnsOnCall map[int]struct {
		result1 error
	}
	SetupTmpDirStub        func() error
	setupTmpDirMutex       sync.RWMutex
	setupTmpDirArgsForCall []struct {
	}
	setupTmpDirReturns struct {
		result1 error
	}
	setupTmpDirReturnsOnCall map[int]struct {
		result1 error
	}
	ShutdownStub        func() error
	shutdownMutex       sync.RWMutex
	shutdownArgsForCall []struct {
	}
	shutdownReturns struct {
		result1 error
	}
	shutdownReturnsOnCall map[int]struct {
		result1 error
	}
	StartMonitStub        func() error
	startMonitMutex       sync.RWMutex
	startMonitArgsForCall []struct {
	}
	startMonitReturns struct {
		result1 error
	}
	startMonitReturnsOnCall map[int]struct {
		result1 error
	}
	UnmountPersistentDiskStub        func(settings.DiskSettings) (bool, error)
	unmountPersistentDiskMutex       sync.RWMutex
	unmountPersistentDiskArgsForCall []struct {
		arg1 settings.DiskSettings
	}
	unmountPersistentDiskReturns struct {
		result1 bool
		result2 error
	}
	unmountPersistentDiskReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePlatform) AddUserToGroups(arg1 string, arg2 []string) error {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.addUserToGroupsMutex.Lock()
	ret, specificReturn := fake.addUserToGroupsReturnsOnCall[len(fake.addUserToGroupsArgsForCall)]
	fake.addUserToGroupsArgsForCall = append(fake.addUserToGroupsArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.AddUserToGroupsStub
	fakeReturns := fake.addUserToGroupsReturns
	fake.recordInvocation("AddUserToGroups", []interface{}{arg1, arg2Copy})
	fake.addUserToGroupsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) AddUserToGroupsCallCount() int {
	fake.addUserToGroupsMutex.RLock()
	defer fake.addUserToGroupsMutex.RUnlock()
	return len(fake.addUserToGroupsArgsForCall)
}

func (fake *FakePlatform) AddUserToGroupsCalls(stub func(string, []string) error) {
	fake.addUserToGroupsMutex.Lock()
	defer fake.addUserToGroupsMutex.Unlock()
	fake.AddUserToGroupsStub = stub
}

func (fake *FakePlatform) AddUserToGroupsArgsForCall(i int) (string, []string) {
	fake.addUserToGroupsMutex.RLock()
	defer fake.addUserToGroupsMutex.RUnlock()
	argsForCall := fake.addUserToGroupsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) AddUserToGroupsReturns(result1 error) {
	fake.addUserToGroupsMutex.Lock()
	defer fake.addUserToGroupsMutex.Unlock()
	fake.AddUserToGroupsStub = nil
	fake.addUserToGroupsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) AddUserToGroupsReturnsOnCall(i int, result1 error) {
	fake.addUserToGroupsMutex.Lock()
	defer fake.addUserToGroupsMutex.Unlock()
	fake.AddUserToGroupsStub = nil
	if fake.addUserToGroupsReturnsOnCall == nil {
		fake.addUserToGroupsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.addUserToGroupsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) AdjustPersistentDiskPartitioning(arg1 settings.DiskSettings, arg2 string) error {
	fake.adjustPersistentDiskPartitioningMutex.Lock()
	ret, specificReturn := fake.adjustPersistentDiskPartitioningReturnsOnCall[len(fake.adjustPersistentDiskPartitioningArgsForCall)]
	fake.adjustPersistentDiskPartitioningArgsForCall = append(fake.adjustPersistentDiskPartitioningArgsForCall, struct {
		arg1 settings.DiskSettings
		arg2 string
	}{arg1, arg2})
	stub := fake.AdjustPersistentDiskPartitioningStub
	fakeReturns := fake.adjustPersistentDiskPartitioningReturns
	fake.recordInvocation("AdjustPersistentDiskPartitioning", []interface{}{arg1, arg2})
	fake.adjustPersistentDiskPartitioningMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) AdjustPersistentDiskPartitioningCallCount() int {
	fake.adjustPersistentDiskPartitioningMutex.RLock()
	defer fake.adjustPersistentDiskPartitioningMutex.RUnlock()
	return len(fake.adjustPersistentDiskPartitioningArgsForCall)
}

func (fake *FakePlatform) AdjustPersistentDiskPartitioningCalls(stub func(settings.DiskSettings, string) error) {
	fake.adjustPersistentDiskPartitioningMutex.Lock()
	defer fake.adjustPersistentDiskPartitioningMutex.Unlock()
	fake.AdjustPersistentDiskPartitioningStub = stub
}

func (fake *FakePlatform) AdjustPersistentDiskPartitioningArgsForCall(i int) (settings.DiskSettings, string) {
	fake.adjustPersistentDiskPartitioningMutex.RLock()
	defer fake.adjustPersistentDiskPartitioningMutex.RUnlock()
	argsForCall := fake.adjustPersistentDiskPartitioningArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) AdjustPersistentDiskPartitioningReturns(result1 error) {
	fake.adjustPersistentDiskPartitioningMutex.Lock()
	defer fake.adjustPersistentDiskPartitioningMutex.Unlock()
	fake.AdjustPersistentDiskPartitioningStub = nil
	fake.adjustPersistentDiskPartitioningReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) AdjustPersistentDiskPartitioningReturnsOnCall(i int, result1 error) {
	fake.adjustPersistentDiskPartitioningMutex.Lock()
	defer fake.adjustPersistentDiskPartitioningMutex.Unlock()
	fake.AdjustPersistentDiskPartitioningStub = nil
	if fake.adjustPersistentDiskPartitioningReturnsOnCall == nil {
		fake.adjustPersistentDiskPartitioningReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.adjustPersistentDiskPartitioningReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) AssociateDisk(arg1 string, arg2 settings.DiskSettings) error {
	fake.associateDiskMutex.Lock()
	ret, specificReturn := fake.associateDiskReturnsOnCall[len(fake.associateDiskArgsForCall)]
	fake.associateDiskArgsForCall = append(fake.associateDiskArgsForCall, struct {
		arg1 string
		arg2 settings.DiskSettings
	}{arg1, arg2})
	stub := fake.AssociateDiskStub
	fakeReturns := fake.associateDiskReturns
	fake.recordInvocation("AssociateDisk", []interface{}{arg1, arg2})
	fake.associateDiskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) AssociateDiskCallCount() int {
	fake.associateDiskMutex.RLock()
	defer fake.associateDiskMutex.RUnlock()
	return len(fake.associateDiskArgsForCall)
}

func (fake *FakePlatform) AssociateDiskCalls(stub func(string, settings.DiskSettings) error) {
	fake.associateDiskMutex.Lock()
	defer fake.associateDiskMutex.Unlock()
	fake.AssociateDiskStub = stub
}

func (fake *FakePlatform) AssociateDiskArgsForCall(i int) (string, settings.DiskSettings) {
	fake.associateDiskMutex.RLock()
	defer fake.associateDiskMutex.RUnlock()
	argsForCall := fake.associateDiskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) AssociateDiskReturns(result1 error) {
	fake.associateDiskMutex.Lock()
	defer fake.associateDiskMutex.Unlock()
	fake.AssociateDiskStub = nil
	fake.associateDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) AssociateDiskReturnsOnCall(i int, result1 error) {
	fake.associateDiskMutex.Lock()
	defer fake.associateDiskMutex.Unlock()
	fake.AssociateDiskStub = nil
	if fake.associateDiskReturnsOnCall == nil {
		fake.associateDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.associateDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) CreateUser(arg1 string, arg2 string) error {
	fake.createUserMutex.Lock()
	ret, specificReturn := fake.createUserReturnsOnCall[len(fake.createUserArgsForCall)]
	fake.createUserArgsForCall = append(fake.createUserArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.CreateUserStub
	fakeReturns := fake.createUserReturns
	fake.recordInvocation("CreateUser", []interface{}{arg1, arg2})
	fake.createUserMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) CreateUserCallCount() int {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	return len(fake.createUserArgsForCall)
}

func (fake *FakePlatform) CreateUserCalls(stub func(string, string) error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = stub
}

func (fake *FakePlatform) CreateUserArgsForCall(i int) (string, string) {
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	argsForCall := fake.createUserArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) CreateUserReturns(result1 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	fake.createUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) CreateUserReturnsOnCall(i int, result1 error) {
	fake.createUserMutex.Lock()
	defer fake.createUserMutex.Unlock()
	fake.CreateUserStub = nil
	if fake.createUserReturnsOnCall == nil {
		fake.createUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) DeleteARPEntryWithIP(arg1 string) error {
	fake.deleteARPEntryWithIPMutex.Lock()
	ret, specificReturn := fake.deleteARPEntryWithIPReturnsOnCall[len(fake.deleteARPEntryWithIPArgsForCall)]
	fake.deleteARPEntryWithIPArgsForCall = append(fake.deleteARPEntryWithIPArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteARPEntryWithIPStub
	fakeReturns := fake.deleteARPEntryWithIPReturns
	fake.recordInvocation("DeleteARPEntryWithIP", []interface{}{arg1})
	fake.deleteARPEntryWithIPMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) DeleteARPEntryWithIPCallCount() int {
	fake.deleteARPEntryWithIPMutex.RLock()
	defer fake.deleteARPEntryWithIPMutex.RUnlock()
	return len(fake.deleteARPEntryWithIPArgsForCall)
}

func (fake *FakePlatform) DeleteARPEntryWithIPCalls(stub func(string) error) {
	fake.deleteARPEntryWithIPMutex.Lock()
	defer fake.deleteARPEntryWithIPMutex.Unlock()
	fake.DeleteARPEntryWithIPStub = stub
}

func (fake *FakePlatform) DeleteARPEntryWithIPArgsForCall(i int) string {
	fake.deleteARPEntryWithIPMutex.RLock()
	defer fake.deleteARPEntryWithIPMutex.RUnlock()
	argsForCall := fake.deleteARPEntryWithIPArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) DeleteARPEntryWithIPReturns(result1 error) {
	fake.deleteARPEntryWithIPMutex.Lock()
	defer fake.deleteARPEntryWithIPMutex.Unlock()
	fake.DeleteARPEntryWithIPStub = nil
	fake.deleteARPEntryWithIPReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) DeleteARPEntryWithIPReturnsOnCall(i int, result1 error) {
	fake.deleteARPEntryWithIPMutex.Lock()
	defer fake.deleteARPEntryWithIPMutex.Unlock()
	fake.DeleteARPEntryWithIPStub = nil
	if fake.deleteARPEntryWithIPReturnsOnCall == nil {
		fake.deleteARPEntryWithIPReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteARPEntryWithIPReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) DeleteEphemeralUsersMatching(arg1 string) error {
	fake.deleteEphemeralUsersMatchingMutex.Lock()
	ret, specificReturn := fake.deleteEphemeralUsersMatchingReturnsOnCall[len(fake.deleteEphemeralUsersMatchingArgsForCall)]
	fake.deleteEphemeralUsersMatchingArgsForCall = append(fake.deleteEphemeralUsersMatchingArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.DeleteEphemeralUsersMatchingStub
	fakeReturns := fake.deleteEphemeralUsersMatchingReturns
	fake.recordInvocation("DeleteEphemeralUsersMatching", []interface{}{arg1})
	fake.deleteEphemeralUsersMatchingMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) DeleteEphemeralUsersMatchingCallCount() int {
	fake.deleteEphemeralUsersMatchingMutex.RLock()
	defer fake.deleteEphemeralUsersMatchingMutex.RUnlock()
	return len(fake.deleteEphemeralUsersMatchingArgsForCall)
}

func (fake *FakePlatform) DeleteEphemeralUsersMatchingCalls(stub func(string) error) {
	fake.deleteEphemeralUsersMatchingMutex.Lock()
	defer fake.deleteEphemeralUsersMatchingMutex.Unlock()
	fake.DeleteEphemeralUsersMatchingStub = stub
}

func (fake *FakePlatform) DeleteEphemeralUsersMatchingArgsForCall(i int) string {
	fake.deleteEphemeralUsersMatchingMutex.RLock()
	defer fake.deleteEphemeralUsersMatchingMutex.RUnlock()
	argsForCall := fake.deleteEphemeralUsersMatchingArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) DeleteEphemeralUsersMatchingReturns(result1 error) {
	fake.deleteEphemeralUsersMatchingMutex.Lock()
	defer fake.deleteEphemeralUsersMatchingMutex.Unlock()
	fake.DeleteEphemeralUsersMatchingStub = nil
	fake.deleteEphemeralUsersMatchingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) DeleteEphemeralUsersMatchingReturnsOnCall(i int, result1 error) {
	fake.deleteEphemeralUsersMatchingMutex.Lock()
	defer fake.deleteEphemeralUsersMatchingMutex.Unlock()
	fake.DeleteEphemeralUsersMatchingStub = nil
	if fake.deleteEphemeralUsersMatchingReturnsOnCall == nil {
		fake.deleteEphemeralUsersMatchingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteEphemeralUsersMatchingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) GetAgentSettingsPath(arg1 bool) string {
	fake.getAgentSettingsPathMutex.Lock()
	ret, specificReturn := fake.getAgentSettingsPathReturnsOnCall[len(fake.getAgentSettingsPathArgsForCall)]
	fake.getAgentSettingsPathArgsForCall = append(fake.getAgentSettingsPathArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.GetAgentSettingsPathStub
	fakeReturns := fake.getAgentSettingsPathReturns
	fake.recordInvocation("GetAgentSettingsPath", []interface{}{arg1})
	fake.getAgentSettingsPathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetAgentSettingsPathCallCount() int {
	fake.getAgentSettingsPathMutex.RLock()
	defer fake.getAgentSettingsPathMutex.RUnlock()
	return len(fake.getAgentSettingsPathArgsForCall)
}

func (fake *FakePlatform) GetAgentSettingsPathCalls(stub func(bool) string) {
	fake.getAgentSettingsPathMutex.Lock()
	defer fake.getAgentSettingsPathMutex.Unlock()
	fake.GetAgentSettingsPathStub = stub
}

func (fake *FakePlatform) GetAgentSettingsPathArgsForCall(i int) bool {
	fake.getAgentSettingsPathMutex.RLock()
	defer fake.getAgentSettingsPathMutex.RUnlock()
	argsForCall := fake.getAgentSettingsPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) GetAgentSettingsPathReturns(result1 string) {
	fake.getAgentSettingsPathMutex.Lock()
	defer fake.getAgentSettingsPathMutex.Unlock()
	fake.GetAgentSettingsPathStub = nil
	fake.getAgentSettingsPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePlatform) GetAgentSettingsPathReturnsOnCall(i int, result1 string) {
	fake.getAgentSettingsPathMutex.Lock()
	defer fake.getAgentSettingsPathMutex.Unlock()
	fake.GetAgentSettingsPathStub = nil
	if fake.getAgentSettingsPathReturnsOnCall == nil {
		fake.getAgentSettingsPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getAgentSettingsPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePlatform) GetAuditLogger() platform.AuditLogger {
	fake.getAuditLoggerMutex.Lock()
	ret, specificReturn := fake.getAuditLoggerReturnsOnCall[len(fake.getAuditLoggerArgsForCall)]
	fake.getAuditLoggerArgsForCall = append(fake.getAuditLoggerArgsForCall, struct {
	}{})
	stub := fake.GetAuditLoggerStub
	fakeReturns := fake.getAuditLoggerReturns
	fake.recordInvocation("GetAuditLogger", []interface{}{})
	fake.getAuditLoggerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetAuditLoggerCallCount() int {
	fake.getAuditLoggerMutex.RLock()
	defer fake.getAuditLoggerMutex.RUnlock()
	return len(fake.getAuditLoggerArgsForCall)
}

func (fake *FakePlatform) GetAuditLoggerCalls(stub func() platform.AuditLogger) {
	fake.getAuditLoggerMutex.Lock()
	defer fake.getAuditLoggerMutex.Unlock()
	fake.GetAuditLoggerStub = stub
}

func (fake *FakePlatform) GetAuditLoggerReturns(result1 platform.AuditLogger) {
	fake.getAuditLoggerMutex.Lock()
	defer fake.getAuditLoggerMutex.Unlock()
	fake.GetAuditLoggerStub = nil
	fake.getAuditLoggerReturns = struct {
		result1 platform.AuditLogger
	}{result1}
}

func (fake *FakePlatform) GetAuditLoggerReturnsOnCall(i int, result1 platform.AuditLogger) {
	fake.getAuditLoggerMutex.Lock()
	defer fake.getAuditLoggerMutex.Unlock()
	fake.GetAuditLoggerStub = nil
	if fake.getAuditLoggerReturnsOnCall == nil {
		fake.getAuditLoggerReturnsOnCall = make(map[int]struct {
			result1 platform.AuditLogger
		})
	}
	fake.getAuditLoggerReturnsOnCall[i] = struct {
		result1 platform.AuditLogger
	}{result1}
}

func (fake *FakePlatform) GetCertManager() cert.Manager {
	fake.getCertManagerMutex.Lock()
	ret, specificReturn := fake.getCertManagerReturnsOnCall[len(fake.getCertManagerArgsForCall)]
	fake.getCertManagerArgsForCall = append(fake.getCertManagerArgsForCall, struct {
	}{})
	stub := fake.GetCertManagerStub
	fakeReturns := fake.getCertManagerReturns
	fake.recordInvocation("GetCertManager", []interface{}{})
	fake.getCertManagerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetCertManagerCallCount() int {
	fake.getCertManagerMutex.RLock()
	defer fake.getCertManagerMutex.RUnlock()
	return len(fake.getCertManagerArgsForCall)
}

func (fake *FakePlatform) GetCertManagerCalls(stub func() cert.Manager) {
	fake.getCertManagerMutex.Lock()
	defer fake.getCertManagerMutex.Unlock()
	fake.GetCertManagerStub = stub
}

func (fake *FakePlatform) GetCertManagerReturns(result1 cert.Manager) {
	fake.getCertManagerMutex.Lock()
	defer fake.getCertManagerMutex.Unlock()
	fake.GetCertManagerStub = nil
	fake.getCertManagerReturns = struct {
		result1 cert.Manager
	}{result1}
}

func (fake *FakePlatform) GetCertManagerReturnsOnCall(i int, result1 cert.Manager) {
	fake.getCertManagerMutex.Lock()
	defer fake.getCertManagerMutex.Unlock()
	fake.GetCertManagerStub = nil
	if fake.getCertManagerReturnsOnCall == nil {
		fake.getCertManagerReturnsOnCall = make(map[int]struct {
			result1 cert.Manager
		})
	}
	fake.getCertManagerReturnsOnCall[i] = struct {
		result1 cert.Manager
	}{result1}
}

func (fake *FakePlatform) GetCompressor() fileutil.Compressor {
	fake.getCompressorMutex.Lock()
	ret, specificReturn := fake.getCompressorReturnsOnCall[len(fake.getCompressorArgsForCall)]
	fake.getCompressorArgsForCall = append(fake.getCompressorArgsForCall, struct {
	}{})
	stub := fake.GetCompressorStub
	fakeReturns := fake.getCompressorReturns
	fake.recordInvocation("GetCompressor", []interface{}{})
	fake.getCompressorMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetCompressorCallCount() int {
	fake.getCompressorMutex.RLock()
	defer fake.getCompressorMutex.RUnlock()
	return len(fake.getCompressorArgsForCall)
}

func (fake *FakePlatform) GetCompressorCalls(stub func() fileutil.Compressor) {
	fake.getCompressorMutex.Lock()
	defer fake.getCompressorMutex.Unlock()
	fake.GetCompressorStub = stub
}

func (fake *FakePlatform) GetCompressorReturns(result1 fileutil.Compressor) {
	fake.getCompressorMutex.Lock()
	defer fake.getCompressorMutex.Unlock()
	fake.GetCompressorStub = nil
	fake.getCompressorReturns = struct {
		result1 fileutil.Compressor
	}{result1}
}

func (fake *FakePlatform) GetCompressorReturnsOnCall(i int, result1 fileutil.Compressor) {
	fake.getCompressorMutex.Lock()
	defer fake.getCompressorMutex.Unlock()
	fake.GetCompressorStub = nil
	if fake.getCompressorReturnsOnCall == nil {
		fake.getCompressorReturnsOnCall = make(map[int]struct {
			result1 fileutil.Compressor
		})
	}
	fake.getCompressorReturnsOnCall[i] = struct {
		result1 fileutil.Compressor
	}{result1}
}

func (fake *FakePlatform) GetConfiguredNetworkInterfaces() ([]string, error) {
	fake.getConfiguredNetworkInterfacesMutex.Lock()
	ret, specificReturn := fake.getConfiguredNetworkInterfacesReturnsOnCall[len(fake.getConfiguredNetworkInterfacesArgsForCall)]
	fake.getConfiguredNetworkInterfacesArgsForCall = append(fake.getConfiguredNetworkInterfacesArgsForCall, struct {
	}{})
	stub := fake.GetConfiguredNetworkInterfacesStub
	fakeReturns := fake.getConfiguredNetworkInterfacesReturns
	fake.recordInvocation("GetConfiguredNetworkInterfaces", []interface{}{})
	fake.getConfiguredNetworkInterfacesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) GetConfiguredNetworkInterfacesCallCount() int {
	fake.getConfiguredNetworkInterfacesMutex.RLock()
	defer fake.getConfiguredNetworkInterfacesMutex.RUnlock()
	return len(fake.getConfiguredNetworkInterfacesArgsForCall)
}

func (fake *FakePlatform) GetConfiguredNetworkInterfacesCalls(stub func() ([]string, error)) {
	fake.getConfiguredNetworkInterfacesMutex.Lock()
	defer fake.getConfiguredNetworkInterfacesMutex.Unlock()
	fake.GetConfiguredNetworkInterfacesStub = stub
}

func (fake *FakePlatform) GetConfiguredNetworkInterfacesReturns(result1 []string, result2 error) {
	fake.getConfiguredNetworkInterfacesMutex.Lock()
	defer fake.getConfiguredNetworkInterfacesMutex.Unlock()
	fake.GetConfiguredNetworkInterfacesStub = nil
	fake.getConfiguredNetworkInterfacesReturns = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetConfiguredNetworkInterfacesReturnsOnCall(i int, result1 []string, result2 error) {
	fake.getConfiguredNetworkInterfacesMutex.Lock()
	defer fake.getConfiguredNetworkInterfacesMutex.Unlock()
	fake.GetConfiguredNetworkInterfacesStub = nil
	if fake.getConfiguredNetworkInterfacesReturnsOnCall == nil {
		fake.getConfiguredNetworkInterfacesReturnsOnCall = make(map[int]struct {
			result1 []string
			result2 error
		})
	}
	fake.getConfiguredNetworkInterfacesReturnsOnCall[i] = struct {
		result1 []string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetCopier() fileutil.Copier {
	fake.getCopierMutex.Lock()
	ret, specificReturn := fake.getCopierReturnsOnCall[len(fake.getCopierArgsForCall)]
	fake.getCopierArgsForCall = append(fake.getCopierArgsForCall, struct {
	}{})
	stub := fake.GetCopierStub
	fakeReturns := fake.getCopierReturns
	fake.recordInvocation("GetCopier", []interface{}{})
	fake.getCopierMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetCopierCallCount() int {
	fake.getCopierMutex.RLock()
	defer fake.getCopierMutex.RUnlock()
	return len(fake.getCopierArgsForCall)
}

func (fake *FakePlatform) GetCopierCalls(stub func() fileutil.Copier) {
	fake.getCopierMutex.Lock()
	defer fake.getCopierMutex.Unlock()
	fake.GetCopierStub = stub
}

func (fake *FakePlatform) GetCopierReturns(result1 fileutil.Copier) {
	fake.getCopierMutex.Lock()
	defer fake.getCopierMutex.Unlock()
	fake.GetCopierStub = nil
	fake.getCopierReturns = struct {
		result1 fileutil.Copier
	}{result1}
}

func (fake *FakePlatform) GetCopierReturnsOnCall(i int, result1 fileutil.Copier) {
	fake.getCopierMutex.Lock()
	defer fake.getCopierMutex.Unlock()
	fake.GetCopierStub = nil
	if fake.getCopierReturnsOnCall == nil {
		fake.getCopierReturnsOnCall = make(map[int]struct {
			result1 fileutil.Copier
		})
	}
	fake.getCopierReturnsOnCall[i] = struct {
		result1 fileutil.Copier
	}{result1}
}

func (fake *FakePlatform) GetDefaultNetwork() (settings.Network, error) {
	fake.getDefaultNetworkMutex.Lock()
	ret, specificReturn := fake.getDefaultNetworkReturnsOnCall[len(fake.getDefaultNetworkArgsForCall)]
	fake.getDefaultNetworkArgsForCall = append(fake.getDefaultNetworkArgsForCall, struct {
	}{})
	stub := fake.GetDefaultNetworkStub
	fakeReturns := fake.getDefaultNetworkReturns
	fake.recordInvocation("GetDefaultNetwork", []interface{}{})
	fake.getDefaultNetworkMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) GetDefaultNetworkCallCount() int {
	fake.getDefaultNetworkMutex.RLock()
	defer fake.getDefaultNetworkMutex.RUnlock()
	return len(fake.getDefaultNetworkArgsForCall)
}

func (fake *FakePlatform) GetDefaultNetworkCalls(stub func() (settings.Network, error)) {
	fake.getDefaultNetworkMutex.Lock()
	defer fake.getDefaultNetworkMutex.Unlock()
	fake.GetDefaultNetworkStub = stub
}

func (fake *FakePlatform) GetDefaultNetworkReturns(result1 settings.Network, result2 error) {
	fake.getDefaultNetworkMutex.Lock()
	defer fake.getDefaultNetworkMutex.Unlock()
	fake.GetDefaultNetworkStub = nil
	fake.getDefaultNetworkReturns = struct {
		result1 settings.Network
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetDefaultNetworkReturnsOnCall(i int, result1 settings.Network, result2 error) {
	fake.getDefaultNetworkMutex.Lock()
	defer fake.getDefaultNetworkMutex.Unlock()
	fake.GetDefaultNetworkStub = nil
	if fake.getDefaultNetworkReturnsOnCall == nil {
		fake.getDefaultNetworkReturnsOnCall = make(map[int]struct {
			result1 settings.Network
			result2 error
		})
	}
	fake.getDefaultNetworkReturnsOnCall[i] = struct {
		result1 settings.Network
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetDevicePathResolver() devicepathresolver.DevicePathResolver {
	fake.getDevicePathResolverMutex.Lock()
	ret, specificReturn := fake.getDevicePathResolverReturnsOnCall[len(fake.getDevicePathResolverArgsForCall)]
	fake.getDevicePathResolverArgsForCall = append(fake.getDevicePathResolverArgsForCall, struct {
	}{})
	stub := fake.GetDevicePathResolverStub
	fakeReturns := fake.getDevicePathResolverReturns
	fake.recordInvocation("GetDevicePathResolver", []interface{}{})
	fake.getDevicePathResolverMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetDevicePathResolverCallCount() int {
	fake.getDevicePathResolverMutex.RLock()
	defer fake.getDevicePathResolverMutex.RUnlock()
	return len(fake.getDevicePathResolverArgsForCall)
}

func (fake *FakePlatform) GetDevicePathResolverCalls(stub func() devicepathresolver.DevicePathResolver) {
	fake.getDevicePathResolverMutex.Lock()
	defer fake.getDevicePathResolverMutex.Unlock()
	fake.GetDevicePathResolverStub = stub
}

func (fake *FakePlatform) GetDevicePathResolverReturns(result1 devicepathresolver.DevicePathResolver) {
	fake.getDevicePathResolverMutex.Lock()
	defer fake.getDevicePathResolverMutex.Unlock()
	fake.GetDevicePathResolverStub = nil
	fake.getDevicePathResolverReturns = struct {
		result1 devicepathresolver.DevicePathResolver
	}{result1}
}

func (fake *FakePlatform) GetDevicePathResolverReturnsOnCall(i int, result1 devicepathresolver.DevicePathResolver) {
	fake.getDevicePathResolverMutex.Lock()
	defer fake.getDevicePathResolverMutex.Unlock()
	fake.GetDevicePathResolverStub = nil
	if fake.getDevicePathResolverReturnsOnCall == nil {
		fake.getDevicePathResolverReturnsOnCall = make(map[int]struct {
			result1 devicepathresolver.DevicePathResolver
		})
	}
	fake.getDevicePathResolverReturnsOnCall[i] = struct {
		result1 devicepathresolver.DevicePathResolver
	}{result1}
}

func (fake *FakePlatform) GetDirProvider() directories.Provider {
	fake.getDirProviderMutex.Lock()
	ret, specificReturn := fake.getDirProviderReturnsOnCall[len(fake.getDirProviderArgsForCall)]
	fake.getDirProviderArgsForCall = append(fake.getDirProviderArgsForCall, struct {
	}{})
	stub := fake.GetDirProviderStub
	fakeReturns := fake.getDirProviderReturns
	fake.recordInvocation("GetDirProvider", []interface{}{})
	fake.getDirProviderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetDirProviderCallCount() int {
	fake.getDirProviderMutex.RLock()
	defer fake.getDirProviderMutex.RUnlock()
	return len(fake.getDirProviderArgsForCall)
}

func (fake *FakePlatform) GetDirProviderCalls(stub func() directories.Provider) {
	fake.getDirProviderMutex.Lock()
	defer fake.getDirProviderMutex.Unlock()
	fake.GetDirProviderStub = stub
}

func (fake *FakePlatform) GetDirProviderReturns(result1 directories.Provider) {
	fake.getDirProviderMutex.Lock()
	defer fake.getDirProviderMutex.Unlock()
	fake.GetDirProviderStub = nil
	fake.getDirProviderReturns = struct {
		result1 directories.Provider
	}{result1}
}

func (fake *FakePlatform) GetDirProviderReturnsOnCall(i int, result1 directories.Provider) {
	fake.getDirProviderMutex.Lock()
	defer fake.getDirProviderMutex.Unlock()
	fake.GetDirProviderStub = nil
	if fake.getDirProviderReturnsOnCall == nil {
		fake.getDirProviderReturnsOnCall = make(map[int]struct {
			result1 directories.Provider
		})
	}
	fake.getDirProviderReturnsOnCall[i] = struct {
		result1 directories.Provider
	}{result1}
}

func (fake *FakePlatform) GetEphemeralDiskPath(arg1 settings.DiskSettings) (string, error) {
	fake.getEphemeralDiskPathMutex.Lock()
	ret, specificReturn := fake.getEphemeralDiskPathReturnsOnCall[len(fake.getEphemeralDiskPathArgsForCall)]
	fake.getEphemeralDiskPathArgsForCall = append(fake.getEphemeralDiskPathArgsForCall, struct {
		arg1 settings.DiskSettings
	}{arg1})
	stub := fake.GetEphemeralDiskPathStub
	fakeReturns := fake.getEphemeralDiskPathReturns
	fake.recordInvocation("GetEphemeralDiskPath", []interface{}{arg1})
	fake.getEphemeralDiskPathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) GetEphemeralDiskPathCallCount() int {
	fake.getEphemeralDiskPathMutex.RLock()
	defer fake.getEphemeralDiskPathMutex.RUnlock()
	return len(fake.getEphemeralDiskPathArgsForCall)
}

func (fake *FakePlatform) GetEphemeralDiskPathCalls(stub func(settings.DiskSettings) (string, error)) {
	fake.getEphemeralDiskPathMutex.Lock()
	defer fake.getEphemeralDiskPathMutex.Unlock()
	fake.GetEphemeralDiskPathStub = stub
}

func (fake *FakePlatform) GetEphemeralDiskPathArgsForCall(i int) settings.DiskSettings {
	fake.getEphemeralDiskPathMutex.RLock()
	defer fake.getEphemeralDiskPathMutex.RUnlock()
	argsForCall := fake.getEphemeralDiskPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) GetEphemeralDiskPathReturns(result1 string, result2 error) {
	fake.getEphemeralDiskPathMutex.Lock()
	defer fake.getEphemeralDiskPathMutex.Unlock()
	fake.GetEphemeralDiskPathStub = nil
	fake.getEphemeralDiskPathReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetEphemeralDiskPathReturnsOnCall(i int, result1 string, result2 error) {
	fake.getEphemeralDiskPathMutex.Lock()
	defer fake.getEphemeralDiskPathMutex.Unlock()
	fake.GetEphemeralDiskPathStub = nil
	if fake.getEphemeralDiskPathReturnsOnCall == nil {
		fake.getEphemeralDiskPathReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getEphemeralDiskPathReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetFileContentsFromCDROM(arg1 string) ([]byte, error) {
	fake.getFileContentsFromCDROMMutex.Lock()
	ret, specificReturn := fake.getFileContentsFromCDROMReturnsOnCall[len(fake.getFileContentsFromCDROMArgsForCall)]
	fake.getFileContentsFromCDROMArgsForCall = append(fake.getFileContentsFromCDROMArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.GetFileContentsFromCDROMStub
	fakeReturns := fake.getFileContentsFromCDROMReturns
	fake.recordInvocation("GetFileContentsFromCDROM", []interface{}{arg1})
	fake.getFileContentsFromCDROMMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) GetFileContentsFromCDROMCallCount() int {
	fake.getFileContentsFromCDROMMutex.RLock()
	defer fake.getFileContentsFromCDROMMutex.RUnlock()
	return len(fake.getFileContentsFromCDROMArgsForCall)
}

func (fake *FakePlatform) GetFileContentsFromCDROMCalls(stub func(string) ([]byte, error)) {
	fake.getFileContentsFromCDROMMutex.Lock()
	defer fake.getFileContentsFromCDROMMutex.Unlock()
	fake.GetFileContentsFromCDROMStub = stub
}

func (fake *FakePlatform) GetFileContentsFromCDROMArgsForCall(i int) string {
	fake.getFileContentsFromCDROMMutex.RLock()
	defer fake.getFileContentsFromCDROMMutex.RUnlock()
	argsForCall := fake.getFileContentsFromCDROMArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) GetFileContentsFromCDROMReturns(result1 []byte, result2 error) {
	fake.getFileContentsFromCDROMMutex.Lock()
	defer fake.getFileContentsFromCDROMMutex.Unlock()
	fake.GetFileContentsFromCDROMStub = nil
	fake.getFileContentsFromCDROMReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetFileContentsFromCDROMReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.getFileContentsFromCDROMMutex.Lock()
	defer fake.getFileContentsFromCDROMMutex.Unlock()
	fake.GetFileContentsFromCDROMStub = nil
	if fake.getFileContentsFromCDROMReturnsOnCall == nil {
		fake.getFileContentsFromCDROMReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.getFileContentsFromCDROMReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetFilesContentsFromDisk(arg1 string, arg2 []string) ([][]byte, error) {
	var arg2Copy []string
	if arg2 != nil {
		arg2Copy = make([]string, len(arg2))
		copy(arg2Copy, arg2)
	}
	fake.getFilesContentsFromDiskMutex.Lock()
	ret, specificReturn := fake.getFilesContentsFromDiskReturnsOnCall[len(fake.getFilesContentsFromDiskArgsForCall)]
	fake.getFilesContentsFromDiskArgsForCall = append(fake.getFilesContentsFromDiskArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2Copy})
	stub := fake.GetFilesContentsFromDiskStub
	fakeReturns := fake.getFilesContentsFromDiskReturns
	fake.recordInvocation("GetFilesContentsFromDisk", []interface{}{arg1, arg2Copy})
	fake.getFilesContentsFromDiskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) GetFilesContentsFromDiskCallCount() int {
	fake.getFilesContentsFromDiskMutex.RLock()
	defer fake.getFilesContentsFromDiskMutex.RUnlock()
	return len(fake.getFilesContentsFromDiskArgsForCall)
}

func (fake *FakePlatform) GetFilesContentsFromDiskCalls(stub func(string, []string) ([][]byte, error)) {
	fake.getFilesContentsFromDiskMutex.Lock()
	defer fake.getFilesContentsFromDiskMutex.Unlock()
	fake.GetFilesContentsFromDiskStub = stub
}

func (fake *FakePlatform) GetFilesContentsFromDiskArgsForCall(i int) (string, []string) {
	fake.getFilesContentsFromDiskMutex.RLock()
	defer fake.getFilesContentsFromDiskMutex.RUnlock()
	argsForCall := fake.getFilesContentsFromDiskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) GetFilesContentsFromDiskReturns(result1 [][]byte, result2 error) {
	fake.getFilesContentsFromDiskMutex.Lock()
	defer fake.getFilesContentsFromDiskMutex.Unlock()
	fake.GetFilesContentsFromDiskStub = nil
	fake.getFilesContentsFromDiskReturns = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetFilesContentsFromDiskReturnsOnCall(i int, result1 [][]byte, result2 error) {
	fake.getFilesContentsFromDiskMutex.Lock()
	defer fake.getFilesContentsFromDiskMutex.Unlock()
	fake.GetFilesContentsFromDiskStub = nil
	if fake.getFilesContentsFromDiskReturnsOnCall == nil {
		fake.getFilesContentsFromDiskReturnsOnCall = make(map[int]struct {
			result1 [][]byte
			result2 error
		})
	}
	fake.getFilesContentsFromDiskReturnsOnCall[i] = struct {
		result1 [][]byte
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetFs() system.FileSystem {
	fake.getFsMutex.Lock()
	ret, specificReturn := fake.getFsReturnsOnCall[len(fake.getFsArgsForCall)]
	fake.getFsArgsForCall = append(fake.getFsArgsForCall, struct {
	}{})
	stub := fake.GetFsStub
	fakeReturns := fake.getFsReturns
	fake.recordInvocation("GetFs", []interface{}{})
	fake.getFsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetFsCallCount() int {
	fake.getFsMutex.RLock()
	defer fake.getFsMutex.RUnlock()
	return len(fake.getFsArgsForCall)
}

func (fake *FakePlatform) GetFsCalls(stub func() system.FileSystem) {
	fake.getFsMutex.Lock()
	defer fake.getFsMutex.Unlock()
	fake.GetFsStub = stub
}

func (fake *FakePlatform) GetFsReturns(result1 system.FileSystem) {
	fake.getFsMutex.Lock()
	defer fake.getFsMutex.Unlock()
	fake.GetFsStub = nil
	fake.getFsReturns = struct {
		result1 system.FileSystem
	}{result1}
}

func (fake *FakePlatform) GetFsReturnsOnCall(i int, result1 system.FileSystem) {
	fake.getFsMutex.Lock()
	defer fake.getFsMutex.Unlock()
	fake.GetFsStub = nil
	if fake.getFsReturnsOnCall == nil {
		fake.getFsReturnsOnCall = make(map[int]struct {
			result1 system.FileSystem
		})
	}
	fake.getFsReturnsOnCall[i] = struct {
		result1 system.FileSystem
	}{result1}
}

func (fake *FakePlatform) GetHostPublicKey() (string, error) {
	fake.getHostPublicKeyMutex.Lock()
	ret, specificReturn := fake.getHostPublicKeyReturnsOnCall[len(fake.getHostPublicKeyArgsForCall)]
	fake.getHostPublicKeyArgsForCall = append(fake.getHostPublicKeyArgsForCall, struct {
	}{})
	stub := fake.GetHostPublicKeyStub
	fakeReturns := fake.getHostPublicKeyReturns
	fake.recordInvocation("GetHostPublicKey", []interface{}{})
	fake.getHostPublicKeyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) GetHostPublicKeyCallCount() int {
	fake.getHostPublicKeyMutex.RLock()
	defer fake.getHostPublicKeyMutex.RUnlock()
	return len(fake.getHostPublicKeyArgsForCall)
}

func (fake *FakePlatform) GetHostPublicKeyCalls(stub func() (string, error)) {
	fake.getHostPublicKeyMutex.Lock()
	defer fake.getHostPublicKeyMutex.Unlock()
	fake.GetHostPublicKeyStub = stub
}

func (fake *FakePlatform) GetHostPublicKeyReturns(result1 string, result2 error) {
	fake.getHostPublicKeyMutex.Lock()
	defer fake.getHostPublicKeyMutex.Unlock()
	fake.GetHostPublicKeyStub = nil
	fake.getHostPublicKeyReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetHostPublicKeyReturnsOnCall(i int, result1 string, result2 error) {
	fake.getHostPublicKeyMutex.Lock()
	defer fake.getHostPublicKeyMutex.Unlock()
	fake.GetHostPublicKeyStub = nil
	if fake.getHostPublicKeyReturnsOnCall == nil {
		fake.getHostPublicKeyReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.getHostPublicKeyReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) GetMonitCredentials() (string, string, error) {
	fake.getMonitCredentialsMutex.Lock()
	ret, specificReturn := fake.getMonitCredentialsReturnsOnCall[len(fake.getMonitCredentialsArgsForCall)]
	fake.getMonitCredentialsArgsForCall = append(fake.getMonitCredentialsArgsForCall, struct {
	}{})
	stub := fake.GetMonitCredentialsStub
	fakeReturns := fake.getMonitCredentialsReturns
	fake.recordInvocation("GetMonitCredentials", []interface{}{})
	fake.getMonitCredentialsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePlatform) GetMonitCredentialsCallCount() int {
	fake.getMonitCredentialsMutex.RLock()
	defer fake.getMonitCredentialsMutex.RUnlock()
	return len(fake.getMonitCredentialsArgsForCall)
}

func (fake *FakePlatform) GetMonitCredentialsCalls(stub func() (string, string, error)) {
	fake.getMonitCredentialsMutex.Lock()
	defer fake.getMonitCredentialsMutex.Unlock()
	fake.GetMonitCredentialsStub = stub
}

func (fake *FakePlatform) GetMonitCredentialsReturns(result1 string, result2 string, result3 error) {
	fake.getMonitCredentialsMutex.Lock()
	defer fake.getMonitCredentialsMutex.Unlock()
	fake.GetMonitCredentialsStub = nil
	fake.getMonitCredentialsReturns = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePlatform) GetMonitCredentialsReturnsOnCall(i int, result1 string, result2 string, result3 error) {
	fake.getMonitCredentialsMutex.Lock()
	defer fake.getMonitCredentialsMutex.Unlock()
	fake.GetMonitCredentialsStub = nil
	if fake.getMonitCredentialsReturnsOnCall == nil {
		fake.getMonitCredentialsReturnsOnCall = make(map[int]struct {
			result1 string
			result2 string
			result3 error
		})
	}
	fake.getMonitCredentialsReturnsOnCall[i] = struct {
		result1 string
		result2 string
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePlatform) GetPersistentDiskSettingsPath(arg1 bool) string {
	fake.getPersistentDiskSettingsPathMutex.Lock()
	ret, specificReturn := fake.getPersistentDiskSettingsPathReturnsOnCall[len(fake.getPersistentDiskSettingsPathArgsForCall)]
	fake.getPersistentDiskSettingsPathArgsForCall = append(fake.getPersistentDiskSettingsPathArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.GetPersistentDiskSettingsPathStub
	fakeReturns := fake.getPersistentDiskSettingsPathReturns
	fake.recordInvocation("GetPersistentDiskSettingsPath", []interface{}{arg1})
	fake.getPersistentDiskSettingsPathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetPersistentDiskSettingsPathCallCount() int {
	fake.getPersistentDiskSettingsPathMutex.RLock()
	defer fake.getPersistentDiskSettingsPathMutex.RUnlock()
	return len(fake.getPersistentDiskSettingsPathArgsForCall)
}

func (fake *FakePlatform) GetPersistentDiskSettingsPathCalls(stub func(bool) string) {
	fake.getPersistentDiskSettingsPathMutex.Lock()
	defer fake.getPersistentDiskSettingsPathMutex.Unlock()
	fake.GetPersistentDiskSettingsPathStub = stub
}

func (fake *FakePlatform) GetPersistentDiskSettingsPathArgsForCall(i int) bool {
	fake.getPersistentDiskSettingsPathMutex.RLock()
	defer fake.getPersistentDiskSettingsPathMutex.RUnlock()
	argsForCall := fake.getPersistentDiskSettingsPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) GetPersistentDiskSettingsPathReturns(result1 string) {
	fake.getPersistentDiskSettingsPathMutex.Lock()
	defer fake.getPersistentDiskSettingsPathMutex.Unlock()
	fake.GetPersistentDiskSettingsPathStub = nil
	fake.getPersistentDiskSettingsPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePlatform) GetPersistentDiskSettingsPathReturnsOnCall(i int, result1 string) {
	fake.getPersistentDiskSettingsPathMutex.Lock()
	defer fake.getPersistentDiskSettingsPathMutex.Unlock()
	fake.GetPersistentDiskSettingsPathStub = nil
	if fake.getPersistentDiskSettingsPathReturnsOnCall == nil {
		fake.getPersistentDiskSettingsPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getPersistentDiskSettingsPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePlatform) GetRunner() system.CmdRunner {
	fake.getRunnerMutex.Lock()
	ret, specificReturn := fake.getRunnerReturnsOnCall[len(fake.getRunnerArgsForCall)]
	fake.getRunnerArgsForCall = append(fake.getRunnerArgsForCall, struct {
	}{})
	stub := fake.GetRunnerStub
	fakeReturns := fake.getRunnerReturns
	fake.recordInvocation("GetRunner", []interface{}{})
	fake.getRunnerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetRunnerCallCount() int {
	fake.getRunnerMutex.RLock()
	defer fake.getRunnerMutex.RUnlock()
	return len(fake.getRunnerArgsForCall)
}

func (fake *FakePlatform) GetRunnerCalls(stub func() system.CmdRunner) {
	fake.getRunnerMutex.Lock()
	defer fake.getRunnerMutex.Unlock()
	fake.GetRunnerStub = stub
}

func (fake *FakePlatform) GetRunnerReturns(result1 system.CmdRunner) {
	fake.getRunnerMutex.Lock()
	defer fake.getRunnerMutex.Unlock()
	fake.GetRunnerStub = nil
	fake.getRunnerReturns = struct {
		result1 system.CmdRunner
	}{result1}
}

func (fake *FakePlatform) GetRunnerReturnsOnCall(i int, result1 system.CmdRunner) {
	fake.getRunnerMutex.Lock()
	defer fake.getRunnerMutex.Unlock()
	fake.GetRunnerStub = nil
	if fake.getRunnerReturnsOnCall == nil {
		fake.getRunnerReturnsOnCall = make(map[int]struct {
			result1 system.CmdRunner
		})
	}
	fake.getRunnerReturnsOnCall[i] = struct {
		result1 system.CmdRunner
	}{result1}
}

func (fake *FakePlatform) GetUpdateSettingsPath(arg1 bool) string {
	fake.getUpdateSettingsPathMutex.Lock()
	ret, specificReturn := fake.getUpdateSettingsPathReturnsOnCall[len(fake.getUpdateSettingsPathArgsForCall)]
	fake.getUpdateSettingsPathArgsForCall = append(fake.getUpdateSettingsPathArgsForCall, struct {
		arg1 bool
	}{arg1})
	stub := fake.GetUpdateSettingsPathStub
	fakeReturns := fake.getUpdateSettingsPathReturns
	fake.recordInvocation("GetUpdateSettingsPath", []interface{}{arg1})
	fake.getUpdateSettingsPathMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetUpdateSettingsPathCallCount() int {
	fake.getUpdateSettingsPathMutex.RLock()
	defer fake.getUpdateSettingsPathMutex.RUnlock()
	return len(fake.getUpdateSettingsPathArgsForCall)
}

func (fake *FakePlatform) GetUpdateSettingsPathCalls(stub func(bool) string) {
	fake.getUpdateSettingsPathMutex.Lock()
	defer fake.getUpdateSettingsPathMutex.Unlock()
	fake.GetUpdateSettingsPathStub = stub
}

func (fake *FakePlatform) GetUpdateSettingsPathArgsForCall(i int) bool {
	fake.getUpdateSettingsPathMutex.RLock()
	defer fake.getUpdateSettingsPathMutex.RUnlock()
	argsForCall := fake.getUpdateSettingsPathArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) GetUpdateSettingsPathReturns(result1 string) {
	fake.getUpdateSettingsPathMutex.Lock()
	defer fake.getUpdateSettingsPathMutex.Unlock()
	fake.GetUpdateSettingsPathStub = nil
	fake.getUpdateSettingsPathReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePlatform) GetUpdateSettingsPathReturnsOnCall(i int, result1 string) {
	fake.getUpdateSettingsPathMutex.Lock()
	defer fake.getUpdateSettingsPathMutex.Unlock()
	fake.GetUpdateSettingsPathStub = nil
	if fake.getUpdateSettingsPathReturnsOnCall == nil {
		fake.getUpdateSettingsPathReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getUpdateSettingsPathReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePlatform) GetVitalsService() vitals.Service {
	fake.getVitalsServiceMutex.Lock()
	ret, specificReturn := fake.getVitalsServiceReturnsOnCall[len(fake.getVitalsServiceArgsForCall)]
	fake.getVitalsServiceArgsForCall = append(fake.getVitalsServiceArgsForCall, struct {
	}{})
	stub := fake.GetVitalsServiceStub
	fakeReturns := fake.getVitalsServiceReturns
	fake.recordInvocation("GetVitalsService", []interface{}{})
	fake.getVitalsServiceMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) GetVitalsServiceCallCount() int {
	fake.getVitalsServiceMutex.RLock()
	defer fake.getVitalsServiceMutex.RUnlock()
	return len(fake.getVitalsServiceArgsForCall)
}

func (fake *FakePlatform) GetVitalsServiceCalls(stub func() vitals.Service) {
	fake.getVitalsServiceMutex.Lock()
	defer fake.getVitalsServiceMutex.Unlock()
	fake.GetVitalsServiceStub = stub
}

func (fake *FakePlatform) GetVitalsServiceReturns(result1 vitals.Service) {
	fake.getVitalsServiceMutex.Lock()
	defer fake.getVitalsServiceMutex.Unlock()
	fake.GetVitalsServiceStub = nil
	fake.getVitalsServiceReturns = struct {
		result1 vitals.Service
	}{result1}
}

func (fake *FakePlatform) GetVitalsServiceReturnsOnCall(i int, result1 vitals.Service) {
	fake.getVitalsServiceMutex.Lock()
	defer fake.getVitalsServiceMutex.Unlock()
	fake.GetVitalsServiceStub = nil
	if fake.getVitalsServiceReturnsOnCall == nil {
		fake.getVitalsServiceReturnsOnCall = make(map[int]struct {
			result1 vitals.Service
		})
	}
	fake.getVitalsServiceReturnsOnCall[i] = struct {
		result1 vitals.Service
	}{result1}
}

func (fake *FakePlatform) IsMountPoint(arg1 string) (string, bool, error) {
	fake.isMountPointMutex.Lock()
	ret, specificReturn := fake.isMountPointReturnsOnCall[len(fake.isMountPointArgsForCall)]
	fake.isMountPointArgsForCall = append(fake.isMountPointArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsMountPointStub
	fakeReturns := fake.isMountPointReturns
	fake.recordInvocation("IsMountPoint", []interface{}{arg1})
	fake.isMountPointMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakePlatform) IsMountPointCallCount() int {
	fake.isMountPointMutex.RLock()
	defer fake.isMountPointMutex.RUnlock()
	return len(fake.isMountPointArgsForCall)
}

func (fake *FakePlatform) IsMountPointCalls(stub func(string) (string, bool, error)) {
	fake.isMountPointMutex.Lock()
	defer fake.isMountPointMutex.Unlock()
	fake.IsMountPointStub = stub
}

func (fake *FakePlatform) IsMountPointArgsForCall(i int) string {
	fake.isMountPointMutex.RLock()
	defer fake.isMountPointMutex.RUnlock()
	argsForCall := fake.isMountPointArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) IsMountPointReturns(result1 string, result2 bool, result3 error) {
	fake.isMountPointMutex.Lock()
	defer fake.isMountPointMutex.Unlock()
	fake.IsMountPointStub = nil
	fake.isMountPointReturns = struct {
		result1 string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePlatform) IsMountPointReturnsOnCall(i int, result1 string, result2 bool, result3 error) {
	fake.isMountPointMutex.Lock()
	defer fake.isMountPointMutex.Unlock()
	fake.IsMountPointStub = nil
	if fake.isMountPointReturnsOnCall == nil {
		fake.isMountPointReturnsOnCall = make(map[int]struct {
			result1 string
			result2 bool
			result3 error
		})
	}
	fake.isMountPointReturnsOnCall[i] = struct {
		result1 string
		result2 bool
		result3 error
	}{result1, result2, result3}
}

func (fake *FakePlatform) IsPersistentDiskMountable(arg1 settings.DiskSettings) (bool, error) {
	fake.isPersistentDiskMountableMutex.Lock()
	ret, specificReturn := fake.isPersistentDiskMountableReturnsOnCall[len(fake.isPersistentDiskMountableArgsForCall)]
	fake.isPersistentDiskMountableArgsForCall = append(fake.isPersistentDiskMountableArgsForCall, struct {
		arg1 settings.DiskSettings
	}{arg1})
	stub := fake.IsPersistentDiskMountableStub
	fakeReturns := fake.isPersistentDiskMountableReturns
	fake.recordInvocation("IsPersistentDiskMountable", []interface{}{arg1})
	fake.isPersistentDiskMountableMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) IsPersistentDiskMountableCallCount() int {
	fake.isPersistentDiskMountableMutex.RLock()
	defer fake.isPersistentDiskMountableMutex.RUnlock()
	return len(fake.isPersistentDiskMountableArgsForCall)
}

func (fake *FakePlatform) IsPersistentDiskMountableCalls(stub func(settings.DiskSettings) (bool, error)) {
	fake.isPersistentDiskMountableMutex.Lock()
	defer fake.isPersistentDiskMountableMutex.Unlock()
	fake.IsPersistentDiskMountableStub = stub
}

func (fake *FakePlatform) IsPersistentDiskMountableArgsForCall(i int) settings.DiskSettings {
	fake.isPersistentDiskMountableMutex.RLock()
	defer fake.isPersistentDiskMountableMutex.RUnlock()
	argsForCall := fake.isPersistentDiskMountableArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) IsPersistentDiskMountableReturns(result1 bool, result2 error) {
	fake.isPersistentDiskMountableMutex.Lock()
	defer fake.isPersistentDiskMountableMutex.Unlock()
	fake.IsPersistentDiskMountableStub = nil
	fake.isPersistentDiskMountableReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) IsPersistentDiskMountableReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isPersistentDiskMountableMutex.Lock()
	defer fake.isPersistentDiskMountableMutex.Unlock()
	fake.IsPersistentDiskMountableStub = nil
	if fake.isPersistentDiskMountableReturnsOnCall == nil {
		fake.isPersistentDiskMountableReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isPersistentDiskMountableReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) IsPersistentDiskMounted(arg1 settings.DiskSettings) (bool, error) {
	fake.isPersistentDiskMountedMutex.Lock()
	ret, specificReturn := fake.isPersistentDiskMountedReturnsOnCall[len(fake.isPersistentDiskMountedArgsForCall)]
	fake.isPersistentDiskMountedArgsForCall = append(fake.isPersistentDiskMountedArgsForCall, struct {
		arg1 settings.DiskSettings
	}{arg1})
	stub := fake.IsPersistentDiskMountedStub
	fakeReturns := fake.isPersistentDiskMountedReturns
	fake.recordInvocation("IsPersistentDiskMounted", []interface{}{arg1})
	fake.isPersistentDiskMountedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) IsPersistentDiskMountedCallCount() int {
	fake.isPersistentDiskMountedMutex.RLock()
	defer fake.isPersistentDiskMountedMutex.RUnlock()
	return len(fake.isPersistentDiskMountedArgsForCall)
}

func (fake *FakePlatform) IsPersistentDiskMountedCalls(stub func(settings.DiskSettings) (bool, error)) {
	fake.isPersistentDiskMountedMutex.Lock()
	defer fake.isPersistentDiskMountedMutex.Unlock()
	fake.IsPersistentDiskMountedStub = stub
}

func (fake *FakePlatform) IsPersistentDiskMountedArgsForCall(i int) settings.DiskSettings {
	fake.isPersistentDiskMountedMutex.RLock()
	defer fake.isPersistentDiskMountedMutex.RUnlock()
	argsForCall := fake.isPersistentDiskMountedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) IsPersistentDiskMountedReturns(result1 bool, result2 error) {
	fake.isPersistentDiskMountedMutex.Lock()
	defer fake.isPersistentDiskMountedMutex.Unlock()
	fake.IsPersistentDiskMountedStub = nil
	fake.isPersistentDiskMountedReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) IsPersistentDiskMountedReturnsOnCall(i int, result1 bool, result2 error) {
	fake.isPersistentDiskMountedMutex.Lock()
	defer fake.isPersistentDiskMountedMutex.Unlock()
	fake.IsPersistentDiskMountedStub = nil
	if fake.isPersistentDiskMountedReturnsOnCall == nil {
		fake.isPersistentDiskMountedReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.isPersistentDiskMountedReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) MigratePersistentDisk(arg1 string, arg2 string) error {
	fake.migratePersistentDiskMutex.Lock()
	ret, specificReturn := fake.migratePersistentDiskReturnsOnCall[len(fake.migratePersistentDiskArgsForCall)]
	fake.migratePersistentDiskArgsForCall = append(fake.migratePersistentDiskArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.MigratePersistentDiskStub
	fakeReturns := fake.migratePersistentDiskReturns
	fake.recordInvocation("MigratePersistentDisk", []interface{}{arg1, arg2})
	fake.migratePersistentDiskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) MigratePersistentDiskCallCount() int {
	fake.migratePersistentDiskMutex.RLock()
	defer fake.migratePersistentDiskMutex.RUnlock()
	return len(fake.migratePersistentDiskArgsForCall)
}

func (fake *FakePlatform) MigratePersistentDiskCalls(stub func(string, string) error) {
	fake.migratePersistentDiskMutex.Lock()
	defer fake.migratePersistentDiskMutex.Unlock()
	fake.MigratePersistentDiskStub = stub
}

func (fake *FakePlatform) MigratePersistentDiskArgsForCall(i int) (string, string) {
	fake.migratePersistentDiskMutex.RLock()
	defer fake.migratePersistentDiskMutex.RUnlock()
	argsForCall := fake.migratePersistentDiskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) MigratePersistentDiskReturns(result1 error) {
	fake.migratePersistentDiskMutex.Lock()
	defer fake.migratePersistentDiskMutex.Unlock()
	fake.MigratePersistentDiskStub = nil
	fake.migratePersistentDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) MigratePersistentDiskReturnsOnCall(i int, result1 error) {
	fake.migratePersistentDiskMutex.Lock()
	defer fake.migratePersistentDiskMutex.Unlock()
	fake.MigratePersistentDiskStub = nil
	if fake.migratePersistentDiskReturnsOnCall == nil {
		fake.migratePersistentDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.migratePersistentDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) MountPersistentDisk(arg1 settings.DiskSettings, arg2 string) error {
	fake.mountPersistentDiskMutex.Lock()
	ret, specificReturn := fake.mountPersistentDiskReturnsOnCall[len(fake.mountPersistentDiskArgsForCall)]
	fake.mountPersistentDiskArgsForCall = append(fake.mountPersistentDiskArgsForCall, struct {
		arg1 settings.DiskSettings
		arg2 string
	}{arg1, arg2})
	stub := fake.MountPersistentDiskStub
	fakeReturns := fake.mountPersistentDiskReturns
	fake.recordInvocation("MountPersistentDisk", []interface{}{arg1, arg2})
	fake.mountPersistentDiskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) MountPersistentDiskCallCount() int {
	fake.mountPersistentDiskMutex.RLock()
	defer fake.mountPersistentDiskMutex.RUnlock()
	return len(fake.mountPersistentDiskArgsForCall)
}

func (fake *FakePlatform) MountPersistentDiskCalls(stub func(settings.DiskSettings, string) error) {
	fake.mountPersistentDiskMutex.Lock()
	defer fake.mountPersistentDiskMutex.Unlock()
	fake.MountPersistentDiskStub = stub
}

func (fake *FakePlatform) MountPersistentDiskArgsForCall(i int) (settings.DiskSettings, string) {
	fake.mountPersistentDiskMutex.RLock()
	defer fake.mountPersistentDiskMutex.RUnlock()
	argsForCall := fake.mountPersistentDiskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) MountPersistentDiskReturns(result1 error) {
	fake.mountPersistentDiskMutex.Lock()
	defer fake.mountPersistentDiskMutex.Unlock()
	fake.MountPersistentDiskStub = nil
	fake.mountPersistentDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) MountPersistentDiskReturnsOnCall(i int, result1 error) {
	fake.mountPersistentDiskMutex.Lock()
	defer fake.mountPersistentDiskMutex.Unlock()
	fake.MountPersistentDiskStub = nil
	if fake.mountPersistentDiskReturnsOnCall == nil {
		fake.mountPersistentDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.mountPersistentDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) PrepareForNetworkingChange() error {
	fake.prepareForNetworkingChangeMutex.Lock()
	ret, specificReturn := fake.prepareForNetworkingChangeReturnsOnCall[len(fake.prepareForNetworkingChangeArgsForCall)]
	fake.prepareForNetworkingChangeArgsForCall = append(fake.prepareForNetworkingChangeArgsForCall, struct {
	}{})
	stub := fake.PrepareForNetworkingChangeStub
	fakeReturns := fake.prepareForNetworkingChangeReturns
	fake.recordInvocation("PrepareForNetworkingChange", []interface{}{})
	fake.prepareForNetworkingChangeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) PrepareForNetworkingChangeCallCount() int {
	fake.prepareForNetworkingChangeMutex.RLock()
	defer fake.prepareForNetworkingChangeMutex.RUnlock()
	return len(fake.prepareForNetworkingChangeArgsForCall)
}

func (fake *FakePlatform) PrepareForNetworkingChangeCalls(stub func() error) {
	fake.prepareForNetworkingChangeMutex.Lock()
	defer fake.prepareForNetworkingChangeMutex.Unlock()
	fake.PrepareForNetworkingChangeStub = stub
}

func (fake *FakePlatform) PrepareForNetworkingChangeReturns(result1 error) {
	fake.prepareForNetworkingChangeMutex.Lock()
	defer fake.prepareForNetworkingChangeMutex.Unlock()
	fake.PrepareForNetworkingChangeStub = nil
	fake.prepareForNetworkingChangeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) PrepareForNetworkingChangeReturnsOnCall(i int, result1 error) {
	fake.prepareForNetworkingChangeMutex.Lock()
	defer fake.prepareForNetworkingChangeMutex.Unlock()
	fake.PrepareForNetworkingChangeStub = nil
	if fake.prepareForNetworkingChangeReturnsOnCall == nil {
		fake.prepareForNetworkingChangeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.prepareForNetworkingChangeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) RemoveDevTools(arg1 string) error {
	fake.removeDevToolsMutex.Lock()
	ret, specificReturn := fake.removeDevToolsReturnsOnCall[len(fake.removeDevToolsArgsForCall)]
	fake.removeDevToolsArgsForCall = append(fake.removeDevToolsArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveDevToolsStub
	fakeReturns := fake.removeDevToolsReturns
	fake.recordInvocation("RemoveDevTools", []interface{}{arg1})
	fake.removeDevToolsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) RemoveDevToolsCallCount() int {
	fake.removeDevToolsMutex.RLock()
	defer fake.removeDevToolsMutex.RUnlock()
	return len(fake.removeDevToolsArgsForCall)
}

func (fake *FakePlatform) RemoveDevToolsCalls(stub func(string) error) {
	fake.removeDevToolsMutex.Lock()
	defer fake.removeDevToolsMutex.Unlock()
	fake.RemoveDevToolsStub = stub
}

func (fake *FakePlatform) RemoveDevToolsArgsForCall(i int) string {
	fake.removeDevToolsMutex.RLock()
	defer fake.removeDevToolsMutex.RUnlock()
	argsForCall := fake.removeDevToolsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) RemoveDevToolsReturns(result1 error) {
	fake.removeDevToolsMutex.Lock()
	defer fake.removeDevToolsMutex.Unlock()
	fake.RemoveDevToolsStub = nil
	fake.removeDevToolsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) RemoveDevToolsReturnsOnCall(i int, result1 error) {
	fake.removeDevToolsMutex.Lock()
	defer fake.removeDevToolsMutex.Unlock()
	fake.RemoveDevToolsStub = nil
	if fake.removeDevToolsReturnsOnCall == nil {
		fake.removeDevToolsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeDevToolsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) RemoveStaticLibraries(arg1 string) error {
	fake.removeStaticLibrariesMutex.Lock()
	ret, specificReturn := fake.removeStaticLibrariesReturnsOnCall[len(fake.removeStaticLibrariesArgsForCall)]
	fake.removeStaticLibrariesArgsForCall = append(fake.removeStaticLibrariesArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.RemoveStaticLibrariesStub
	fakeReturns := fake.removeStaticLibrariesReturns
	fake.recordInvocation("RemoveStaticLibraries", []interface{}{arg1})
	fake.removeStaticLibrariesMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) RemoveStaticLibrariesCallCount() int {
	fake.removeStaticLibrariesMutex.RLock()
	defer fake.removeStaticLibrariesMutex.RUnlock()
	return len(fake.removeStaticLibrariesArgsForCall)
}

func (fake *FakePlatform) RemoveStaticLibrariesCalls(stub func(string) error) {
	fake.removeStaticLibrariesMutex.Lock()
	defer fake.removeStaticLibrariesMutex.Unlock()
	fake.RemoveStaticLibrariesStub = stub
}

func (fake *FakePlatform) RemoveStaticLibrariesArgsForCall(i int) string {
	fake.removeStaticLibrariesMutex.RLock()
	defer fake.removeStaticLibrariesMutex.RUnlock()
	argsForCall := fake.removeStaticLibrariesArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) RemoveStaticLibrariesReturns(result1 error) {
	fake.removeStaticLibrariesMutex.Lock()
	defer fake.removeStaticLibrariesMutex.Unlock()
	fake.RemoveStaticLibrariesStub = nil
	fake.removeStaticLibrariesReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) RemoveStaticLibrariesReturnsOnCall(i int, result1 error) {
	fake.removeStaticLibrariesMutex.Lock()
	defer fake.removeStaticLibrariesMutex.Unlock()
	fake.RemoveStaticLibrariesStub = nil
	if fake.removeStaticLibrariesReturnsOnCall == nil {
		fake.removeStaticLibrariesReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.removeStaticLibrariesReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SaveDNSRecords(arg1 settings.DNSRecords, arg2 string) error {
	fake.saveDNSRecordsMutex.Lock()
	ret, specificReturn := fake.saveDNSRecordsReturnsOnCall[len(fake.saveDNSRecordsArgsForCall)]
	fake.saveDNSRecordsArgsForCall = append(fake.saveDNSRecordsArgsForCall, struct {
		arg1 settings.DNSRecords
		arg2 string
	}{arg1, arg2})
	stub := fake.SaveDNSRecordsStub
	fakeReturns := fake.saveDNSRecordsReturns
	fake.recordInvocation("SaveDNSRecords", []interface{}{arg1, arg2})
	fake.saveDNSRecordsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SaveDNSRecordsCallCount() int {
	fake.saveDNSRecordsMutex.RLock()
	defer fake.saveDNSRecordsMutex.RUnlock()
	return len(fake.saveDNSRecordsArgsForCall)
}

func (fake *FakePlatform) SaveDNSRecordsCalls(stub func(settings.DNSRecords, string) error) {
	fake.saveDNSRecordsMutex.Lock()
	defer fake.saveDNSRecordsMutex.Unlock()
	fake.SaveDNSRecordsStub = stub
}

func (fake *FakePlatform) SaveDNSRecordsArgsForCall(i int) (settings.DNSRecords, string) {
	fake.saveDNSRecordsMutex.RLock()
	defer fake.saveDNSRecordsMutex.RUnlock()
	argsForCall := fake.saveDNSRecordsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) SaveDNSRecordsReturns(result1 error) {
	fake.saveDNSRecordsMutex.Lock()
	defer fake.saveDNSRecordsMutex.Unlock()
	fake.SaveDNSRecordsStub = nil
	fake.saveDNSRecordsReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SaveDNSRecordsReturnsOnCall(i int, result1 error) {
	fake.saveDNSRecordsMutex.Lock()
	defer fake.saveDNSRecordsMutex.Unlock()
	fake.SaveDNSRecordsStub = nil
	if fake.saveDNSRecordsReturnsOnCall == nil {
		fake.saveDNSRecordsReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveDNSRecordsReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetTimeWithNtpServers(arg1 []string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setTimeWithNtpServersMutex.Lock()
	ret, specificReturn := fake.setTimeWithNtpServersReturnsOnCall[len(fake.setTimeWithNtpServersArgsForCall)]
	fake.setTimeWithNtpServersArgsForCall = append(fake.setTimeWithNtpServersArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.SetTimeWithNtpServersStub
	fakeReturns := fake.setTimeWithNtpServersReturns
	fake.recordInvocation("SetTimeWithNtpServers", []interface{}{arg1Copy})
	fake.setTimeWithNtpServersMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetTimeWithNtpServersCallCount() int {
	fake.setTimeWithNtpServersMutex.RLock()
	defer fake.setTimeWithNtpServersMutex.RUnlock()
	return len(fake.setTimeWithNtpServersArgsForCall)
}

func (fake *FakePlatform) SetTimeWithNtpServersCalls(stub func([]string) error) {
	fake.setTimeWithNtpServersMutex.Lock()
	defer fake.setTimeWithNtpServersMutex.Unlock()
	fake.SetTimeWithNtpServersStub = stub
}

func (fake *FakePlatform) SetTimeWithNtpServersArgsForCall(i int) []string {
	fake.setTimeWithNtpServersMutex.RLock()
	defer fake.setTimeWithNtpServersMutex.RUnlock()
	argsForCall := fake.setTimeWithNtpServersArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) SetTimeWithNtpServersReturns(result1 error) {
	fake.setTimeWithNtpServersMutex.Lock()
	defer fake.setTimeWithNtpServersMutex.Unlock()
	fake.SetTimeWithNtpServersStub = nil
	fake.setTimeWithNtpServersReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetTimeWithNtpServersReturnsOnCall(i int, result1 error) {
	fake.setTimeWithNtpServersMutex.Lock()
	defer fake.setTimeWithNtpServersMutex.Unlock()
	fake.SetTimeWithNtpServersStub = nil
	if fake.setTimeWithNtpServersReturnsOnCall == nil {
		fake.setTimeWithNtpServersReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setTimeWithNtpServersReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetUserPassword(arg1 string, arg2 string) error {
	fake.setUserPasswordMutex.Lock()
	ret, specificReturn := fake.setUserPasswordReturnsOnCall[len(fake.setUserPasswordArgsForCall)]
	fake.setUserPasswordArgsForCall = append(fake.setUserPasswordArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	stub := fake.SetUserPasswordStub
	fakeReturns := fake.setUserPasswordReturns
	fake.recordInvocation("SetUserPassword", []interface{}{arg1, arg2})
	fake.setUserPasswordMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetUserPasswordCallCount() int {
	fake.setUserPasswordMutex.RLock()
	defer fake.setUserPasswordMutex.RUnlock()
	return len(fake.setUserPasswordArgsForCall)
}

func (fake *FakePlatform) SetUserPasswordCalls(stub func(string, string) error) {
	fake.setUserPasswordMutex.Lock()
	defer fake.setUserPasswordMutex.Unlock()
	fake.SetUserPasswordStub = stub
}

func (fake *FakePlatform) SetUserPasswordArgsForCall(i int) (string, string) {
	fake.setUserPasswordMutex.RLock()
	defer fake.setUserPasswordMutex.RUnlock()
	argsForCall := fake.setUserPasswordArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) SetUserPasswordReturns(result1 error) {
	fake.setUserPasswordMutex.Lock()
	defer fake.setUserPasswordMutex.Unlock()
	fake.SetUserPasswordStub = nil
	fake.setUserPasswordReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetUserPasswordReturnsOnCall(i int, result1 error) {
	fake.setUserPasswordMutex.Lock()
	defer fake.setUserPasswordMutex.Unlock()
	fake.SetUserPasswordStub = nil
	if fake.setUserPasswordReturnsOnCall == nil {
		fake.setUserPasswordReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setUserPasswordReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupBlobsDir() error {
	fake.setupBlobsDirMutex.Lock()
	ret, specificReturn := fake.setupBlobsDirReturnsOnCall[len(fake.setupBlobsDirArgsForCall)]
	fake.setupBlobsDirArgsForCall = append(fake.setupBlobsDirArgsForCall, struct {
	}{})
	stub := fake.SetupBlobsDirStub
	fakeReturns := fake.setupBlobsDirReturns
	fake.recordInvocation("SetupBlobsDir", []interface{}{})
	fake.setupBlobsDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupBlobsDirCallCount() int {
	fake.setupBlobsDirMutex.RLock()
	defer fake.setupBlobsDirMutex.RUnlock()
	return len(fake.setupBlobsDirArgsForCall)
}

func (fake *FakePlatform) SetupBlobsDirCalls(stub func() error) {
	fake.setupBlobsDirMutex.Lock()
	defer fake.setupBlobsDirMutex.Unlock()
	fake.SetupBlobsDirStub = stub
}

func (fake *FakePlatform) SetupBlobsDirReturns(result1 error) {
	fake.setupBlobsDirMutex.Lock()
	defer fake.setupBlobsDirMutex.Unlock()
	fake.SetupBlobsDirStub = nil
	fake.setupBlobsDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupBlobsDirReturnsOnCall(i int, result1 error) {
	fake.setupBlobsDirMutex.Lock()
	defer fake.setupBlobsDirMutex.Unlock()
	fake.SetupBlobsDirStub = nil
	if fake.setupBlobsDirReturnsOnCall == nil {
		fake.setupBlobsDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupBlobsDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupBoshSettingsDisk() error {
	fake.setupBoshSettingsDiskMutex.Lock()
	ret, specificReturn := fake.setupBoshSettingsDiskReturnsOnCall[len(fake.setupBoshSettingsDiskArgsForCall)]
	fake.setupBoshSettingsDiskArgsForCall = append(fake.setupBoshSettingsDiskArgsForCall, struct {
	}{})
	stub := fake.SetupBoshSettingsDiskStub
	fakeReturns := fake.setupBoshSettingsDiskReturns
	fake.recordInvocation("SetupBoshSettingsDisk", []interface{}{})
	fake.setupBoshSettingsDiskMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupBoshSettingsDiskCallCount() int {
	fake.setupBoshSettingsDiskMutex.RLock()
	defer fake.setupBoshSettingsDiskMutex.RUnlock()
	return len(fake.setupBoshSettingsDiskArgsForCall)
}

func (fake *FakePlatform) SetupBoshSettingsDiskCalls(stub func() error) {
	fake.setupBoshSettingsDiskMutex.Lock()
	defer fake.setupBoshSettingsDiskMutex.Unlock()
	fake.SetupBoshSettingsDiskStub = stub
}

func (fake *FakePlatform) SetupBoshSettingsDiskReturns(result1 error) {
	fake.setupBoshSettingsDiskMutex.Lock()
	defer fake.setupBoshSettingsDiskMutex.Unlock()
	fake.SetupBoshSettingsDiskStub = nil
	fake.setupBoshSettingsDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupBoshSettingsDiskReturnsOnCall(i int, result1 error) {
	fake.setupBoshSettingsDiskMutex.Lock()
	defer fake.setupBoshSettingsDiskMutex.Unlock()
	fake.SetupBoshSettingsDiskStub = nil
	if fake.setupBoshSettingsDiskReturnsOnCall == nil {
		fake.setupBoshSettingsDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupBoshSettingsDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupCanRestartDir() error {
	fake.setupCanRestartDirMutex.Lock()
	ret, specificReturn := fake.setupCanRestartDirReturnsOnCall[len(fake.setupCanRestartDirArgsForCall)]
	fake.setupCanRestartDirArgsForCall = append(fake.setupCanRestartDirArgsForCall, struct {
	}{})
	stub := fake.SetupCanRestartDirStub
	fakeReturns := fake.setupCanRestartDirReturns
	fake.recordInvocation("SetupCanRestartDir", []interface{}{})
	fake.setupCanRestartDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupCanRestartDirCallCount() int {
	fake.setupCanRestartDirMutex.RLock()
	defer fake.setupCanRestartDirMutex.RUnlock()
	return len(fake.setupCanRestartDirArgsForCall)
}

func (fake *FakePlatform) SetupCanRestartDirCalls(stub func() error) {
	fake.setupCanRestartDirMutex.Lock()
	defer fake.setupCanRestartDirMutex.Unlock()
	fake.SetupCanRestartDirStub = stub
}

func (fake *FakePlatform) SetupCanRestartDirReturns(result1 error) {
	fake.setupCanRestartDirMutex.Lock()
	defer fake.setupCanRestartDirMutex.Unlock()
	fake.SetupCanRestartDirStub = nil
	fake.setupCanRestartDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupCanRestartDirReturnsOnCall(i int, result1 error) {
	fake.setupCanRestartDirMutex.Lock()
	defer fake.setupCanRestartDirMutex.Unlock()
	fake.SetupCanRestartDirStub = nil
	if fake.setupCanRestartDirReturnsOnCall == nil {
		fake.setupCanRestartDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupCanRestartDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupDataDir(arg1 settings.JobDir, arg2 settings.RunDir) error {
	fake.setupDataDirMutex.Lock()
	ret, specificReturn := fake.setupDataDirReturnsOnCall[len(fake.setupDataDirArgsForCall)]
	fake.setupDataDirArgsForCall = append(fake.setupDataDirArgsForCall, struct {
		arg1 settings.JobDir
		arg2 settings.RunDir
	}{arg1, arg2})
	stub := fake.SetupDataDirStub
	fakeReturns := fake.setupDataDirReturns
	fake.recordInvocation("SetupDataDir", []interface{}{arg1, arg2})
	fake.setupDataDirMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupDataDirCallCount() int {
	fake.setupDataDirMutex.RLock()
	defer fake.setupDataDirMutex.RUnlock()
	return len(fake.setupDataDirArgsForCall)
}

func (fake *FakePlatform) SetupDataDirCalls(stub func(settings.JobDir, settings.RunDir) error) {
	fake.setupDataDirMutex.Lock()
	defer fake.setupDataDirMutex.Unlock()
	fake.SetupDataDirStub = stub
}

func (fake *FakePlatform) SetupDataDirArgsForCall(i int) (settings.JobDir, settings.RunDir) {
	fake.setupDataDirMutex.RLock()
	defer fake.setupDataDirMutex.RUnlock()
	argsForCall := fake.setupDataDirArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) SetupDataDirReturns(result1 error) {
	fake.setupDataDirMutex.Lock()
	defer fake.setupDataDirMutex.Unlock()
	fake.SetupDataDirStub = nil
	fake.setupDataDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupDataDirReturnsOnCall(i int, result1 error) {
	fake.setupDataDirMutex.Lock()
	defer fake.setupDataDirMutex.Unlock()
	fake.SetupDataDirStub = nil
	if fake.setupDataDirReturnsOnCall == nil {
		fake.setupDataDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupDataDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupEphemeralDiskWithPath(arg1 string, arg2 *uint64, arg3 string) error {
	fake.setupEphemeralDiskWithPathMutex.Lock()
	ret, specificReturn := fake.setupEphemeralDiskWithPathReturnsOnCall[len(fake.setupEphemeralDiskWithPathArgsForCall)]
	fake.setupEphemeralDiskWithPathArgsForCall = append(fake.setupEphemeralDiskWithPathArgsForCall, struct {
		arg1 string
		arg2 *uint64
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.SetupEphemeralDiskWithPathStub
	fakeReturns := fake.setupEphemeralDiskWithPathReturns
	fake.recordInvocation("SetupEphemeralDiskWithPath", []interface{}{arg1, arg2, arg3})
	fake.setupEphemeralDiskWithPathMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupEphemeralDiskWithPathCallCount() int {
	fake.setupEphemeralDiskWithPathMutex.RLock()
	defer fake.setupEphemeralDiskWithPathMutex.RUnlock()
	return len(fake.setupEphemeralDiskWithPathArgsForCall)
}

func (fake *FakePlatform) SetupEphemeralDiskWithPathCalls(stub func(string, *uint64, string) error) {
	fake.setupEphemeralDiskWithPathMutex.Lock()
	defer fake.setupEphemeralDiskWithPathMutex.Unlock()
	fake.SetupEphemeralDiskWithPathStub = stub
}

func (fake *FakePlatform) SetupEphemeralDiskWithPathArgsForCall(i int) (string, *uint64, string) {
	fake.setupEphemeralDiskWithPathMutex.RLock()
	defer fake.setupEphemeralDiskWithPathMutex.RUnlock()
	argsForCall := fake.setupEphemeralDiskWithPathArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePlatform) SetupEphemeralDiskWithPathReturns(result1 error) {
	fake.setupEphemeralDiskWithPathMutex.Lock()
	defer fake.setupEphemeralDiskWithPathMutex.Unlock()
	fake.SetupEphemeralDiskWithPathStub = nil
	fake.setupEphemeralDiskWithPathReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupEphemeralDiskWithPathReturnsOnCall(i int, result1 error) {
	fake.setupEphemeralDiskWithPathMutex.Lock()
	defer fake.setupEphemeralDiskWithPathMutex.Unlock()
	fake.SetupEphemeralDiskWithPathStub = nil
	if fake.setupEphemeralDiskWithPathReturnsOnCall == nil {
		fake.setupEphemeralDiskWithPathReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupEphemeralDiskWithPathReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupHomeDir() error {
	fake.setupHomeDirMutex.Lock()
	ret, specificReturn := fake.setupHomeDirReturnsOnCall[len(fake.setupHomeDirArgsForCall)]
	fake.setupHomeDirArgsForCall = append(fake.setupHomeDirArgsForCall, struct {
	}{})
	stub := fake.SetupHomeDirStub
	fakeReturns := fake.setupHomeDirReturns
	fake.recordInvocation("SetupHomeDir", []interface{}{})
	fake.setupHomeDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupHomeDirCallCount() int {
	fake.setupHomeDirMutex.RLock()
	defer fake.setupHomeDirMutex.RUnlock()
	return len(fake.setupHomeDirArgsForCall)
}

func (fake *FakePlatform) SetupHomeDirCalls(stub func() error) {
	fake.setupHomeDirMutex.Lock()
	defer fake.setupHomeDirMutex.Unlock()
	fake.SetupHomeDirStub = stub
}

func (fake *FakePlatform) SetupHomeDirReturns(result1 error) {
	fake.setupHomeDirMutex.Lock()
	defer fake.setupHomeDirMutex.Unlock()
	fake.SetupHomeDirStub = nil
	fake.setupHomeDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupHomeDirReturnsOnCall(i int, result1 error) {
	fake.setupHomeDirMutex.Lock()
	defer fake.setupHomeDirMutex.Unlock()
	fake.SetupHomeDirStub = nil
	if fake.setupHomeDirReturnsOnCall == nil {
		fake.setupHomeDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupHomeDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupHostname(arg1 string) error {
	fake.setupHostnameMutex.Lock()
	ret, specificReturn := fake.setupHostnameReturnsOnCall[len(fake.setupHostnameArgsForCall)]
	fake.setupHostnameArgsForCall = append(fake.setupHostnameArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetupHostnameStub
	fakeReturns := fake.setupHostnameReturns
	fake.recordInvocation("SetupHostname", []interface{}{arg1})
	fake.setupHostnameMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupHostnameCallCount() int {
	fake.setupHostnameMutex.RLock()
	defer fake.setupHostnameMutex.RUnlock()
	return len(fake.setupHostnameArgsForCall)
}

func (fake *FakePlatform) SetupHostnameCalls(stub func(string) error) {
	fake.setupHostnameMutex.Lock()
	defer fake.setupHostnameMutex.Unlock()
	fake.SetupHostnameStub = stub
}

func (fake *FakePlatform) SetupHostnameArgsForCall(i int) string {
	fake.setupHostnameMutex.RLock()
	defer fake.setupHostnameMutex.RUnlock()
	argsForCall := fake.setupHostnameArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) SetupHostnameReturns(result1 error) {
	fake.setupHostnameMutex.Lock()
	defer fake.setupHostnameMutex.Unlock()
	fake.SetupHostnameStub = nil
	fake.setupHostnameReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupHostnameReturnsOnCall(i int, result1 error) {
	fake.setupHostnameMutex.Lock()
	defer fake.setupHostnameMutex.Unlock()
	fake.SetupHostnameStub = nil
	if fake.setupHostnameReturnsOnCall == nil {
		fake.setupHostnameReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupHostnameReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupIPv6(arg1 settings.IPv6) error {
	fake.setupIPv6Mutex.Lock()
	ret, specificReturn := fake.setupIPv6ReturnsOnCall[len(fake.setupIPv6ArgsForCall)]
	fake.setupIPv6ArgsForCall = append(fake.setupIPv6ArgsForCall, struct {
		arg1 settings.IPv6
	}{arg1})
	stub := fake.SetupIPv6Stub
	fakeReturns := fake.setupIPv6Returns
	fake.recordInvocation("SetupIPv6", []interface{}{arg1})
	fake.setupIPv6Mutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupIPv6CallCount() int {
	fake.setupIPv6Mutex.RLock()
	defer fake.setupIPv6Mutex.RUnlock()
	return len(fake.setupIPv6ArgsForCall)
}

func (fake *FakePlatform) SetupIPv6Calls(stub func(settings.IPv6) error) {
	fake.setupIPv6Mutex.Lock()
	defer fake.setupIPv6Mutex.Unlock()
	fake.SetupIPv6Stub = stub
}

func (fake *FakePlatform) SetupIPv6ArgsForCall(i int) settings.IPv6 {
	fake.setupIPv6Mutex.RLock()
	defer fake.setupIPv6Mutex.RUnlock()
	argsForCall := fake.setupIPv6ArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) SetupIPv6Returns(result1 error) {
	fake.setupIPv6Mutex.Lock()
	defer fake.setupIPv6Mutex.Unlock()
	fake.SetupIPv6Stub = nil
	fake.setupIPv6Returns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupIPv6ReturnsOnCall(i int, result1 error) {
	fake.setupIPv6Mutex.Lock()
	defer fake.setupIPv6Mutex.Unlock()
	fake.SetupIPv6Stub = nil
	if fake.setupIPv6ReturnsOnCall == nil {
		fake.setupIPv6ReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupIPv6ReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupLogDir() error {
	fake.setupLogDirMutex.Lock()
	ret, specificReturn := fake.setupLogDirReturnsOnCall[len(fake.setupLogDirArgsForCall)]
	fake.setupLogDirArgsForCall = append(fake.setupLogDirArgsForCall, struct {
	}{})
	stub := fake.SetupLogDirStub
	fakeReturns := fake.setupLogDirReturns
	fake.recordInvocation("SetupLogDir", []interface{}{})
	fake.setupLogDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupLogDirCallCount() int {
	fake.setupLogDirMutex.RLock()
	defer fake.setupLogDirMutex.RUnlock()
	return len(fake.setupLogDirArgsForCall)
}

func (fake *FakePlatform) SetupLogDirCalls(stub func() error) {
	fake.setupLogDirMutex.Lock()
	defer fake.setupLogDirMutex.Unlock()
	fake.SetupLogDirStub = stub
}

func (fake *FakePlatform) SetupLogDirReturns(result1 error) {
	fake.setupLogDirMutex.Lock()
	defer fake.setupLogDirMutex.Unlock()
	fake.SetupLogDirStub = nil
	fake.setupLogDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupLogDirReturnsOnCall(i int, result1 error) {
	fake.setupLogDirMutex.Lock()
	defer fake.setupLogDirMutex.Unlock()
	fake.SetupLogDirStub = nil
	if fake.setupLogDirReturnsOnCall == nil {
		fake.setupLogDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupLogDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupLoggingAndAuditing() error {
	fake.setupLoggingAndAuditingMutex.Lock()
	ret, specificReturn := fake.setupLoggingAndAuditingReturnsOnCall[len(fake.setupLoggingAndAuditingArgsForCall)]
	fake.setupLoggingAndAuditingArgsForCall = append(fake.setupLoggingAndAuditingArgsForCall, struct {
	}{})
	stub := fake.SetupLoggingAndAuditingStub
	fakeReturns := fake.setupLoggingAndAuditingReturns
	fake.recordInvocation("SetupLoggingAndAuditing", []interface{}{})
	fake.setupLoggingAndAuditingMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupLoggingAndAuditingCallCount() int {
	fake.setupLoggingAndAuditingMutex.RLock()
	defer fake.setupLoggingAndAuditingMutex.RUnlock()
	return len(fake.setupLoggingAndAuditingArgsForCall)
}

func (fake *FakePlatform) SetupLoggingAndAuditingCalls(stub func() error) {
	fake.setupLoggingAndAuditingMutex.Lock()
	defer fake.setupLoggingAndAuditingMutex.Unlock()
	fake.SetupLoggingAndAuditingStub = stub
}

func (fake *FakePlatform) SetupLoggingAndAuditingReturns(result1 error) {
	fake.setupLoggingAndAuditingMutex.Lock()
	defer fake.setupLoggingAndAuditingMutex.Unlock()
	fake.SetupLoggingAndAuditingStub = nil
	fake.setupLoggingAndAuditingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupLoggingAndAuditingReturnsOnCall(i int, result1 error) {
	fake.setupLoggingAndAuditingMutex.Lock()
	defer fake.setupLoggingAndAuditingMutex.Unlock()
	fake.SetupLoggingAndAuditingStub = nil
	if fake.setupLoggingAndAuditingReturnsOnCall == nil {
		fake.setupLoggingAndAuditingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupLoggingAndAuditingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupLogrotate(arg1 string, arg2 string, arg3 string) error {
	fake.setupLogrotateMutex.Lock()
	ret, specificReturn := fake.setupLogrotateReturnsOnCall[len(fake.setupLogrotateArgsForCall)]
	fake.setupLogrotateArgsForCall = append(fake.setupLogrotateArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.SetupLogrotateStub
	fakeReturns := fake.setupLogrotateReturns
	fake.recordInvocation("SetupLogrotate", []interface{}{arg1, arg2, arg3})
	fake.setupLogrotateMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupLogrotateCallCount() int {
	fake.setupLogrotateMutex.RLock()
	defer fake.setupLogrotateMutex.RUnlock()
	return len(fake.setupLogrotateArgsForCall)
}

func (fake *FakePlatform) SetupLogrotateCalls(stub func(string, string, string) error) {
	fake.setupLogrotateMutex.Lock()
	defer fake.setupLogrotateMutex.Unlock()
	fake.SetupLogrotateStub = stub
}

func (fake *FakePlatform) SetupLogrotateArgsForCall(i int) (string, string, string) {
	fake.setupLogrotateMutex.RLock()
	defer fake.setupLogrotateMutex.RUnlock()
	argsForCall := fake.setupLogrotateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePlatform) SetupLogrotateReturns(result1 error) {
	fake.setupLogrotateMutex.Lock()
	defer fake.setupLogrotateMutex.Unlock()
	fake.SetupLogrotateStub = nil
	fake.setupLogrotateReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupLogrotateReturnsOnCall(i int, result1 error) {
	fake.setupLogrotateMutex.Lock()
	defer fake.setupLogrotateMutex.Unlock()
	fake.SetupLogrotateStub = nil
	if fake.setupLogrotateReturnsOnCall == nil {
		fake.setupLogrotateReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupLogrotateReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupMonitUser() error {
	fake.setupMonitUserMutex.Lock()
	ret, specificReturn := fake.setupMonitUserReturnsOnCall[len(fake.setupMonitUserArgsForCall)]
	fake.setupMonitUserArgsForCall = append(fake.setupMonitUserArgsForCall, struct {
	}{})
	stub := fake.SetupMonitUserStub
	fakeReturns := fake.setupMonitUserReturns
	fake.recordInvocation("SetupMonitUser", []interface{}{})
	fake.setupMonitUserMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupMonitUserCallCount() int {
	fake.setupMonitUserMutex.RLock()
	defer fake.setupMonitUserMutex.RUnlock()
	return len(fake.setupMonitUserArgsForCall)
}

func (fake *FakePlatform) SetupMonitUserCalls(stub func() error) {
	fake.setupMonitUserMutex.Lock()
	defer fake.setupMonitUserMutex.Unlock()
	fake.SetupMonitUserStub = stub
}

func (fake *FakePlatform) SetupMonitUserReturns(result1 error) {
	fake.setupMonitUserMutex.Lock()
	defer fake.setupMonitUserMutex.Unlock()
	fake.SetupMonitUserStub = nil
	fake.setupMonitUserReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupMonitUserReturnsOnCall(i int, result1 error) {
	fake.setupMonitUserMutex.Lock()
	defer fake.setupMonitUserMutex.Unlock()
	fake.SetupMonitUserStub = nil
	if fake.setupMonitUserReturnsOnCall == nil {
		fake.setupMonitUserReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupMonitUserReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupNetworking(arg1 settings.Networks, arg2 string) error {
	fake.setupNetworkingMutex.Lock()
	ret, specificReturn := fake.setupNetworkingReturnsOnCall[len(fake.setupNetworkingArgsForCall)]
	fake.setupNetworkingArgsForCall = append(fake.setupNetworkingArgsForCall, struct {
		arg1 settings.Networks
		arg2 string
	}{arg1, arg2})
	stub := fake.SetupNetworkingStub
	fakeReturns := fake.setupNetworkingReturns
	fake.recordInvocation("SetupNetworking", []interface{}{arg1, arg2})
	fake.setupNetworkingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupNetworkingCallCount() int {
	fake.setupNetworkingMutex.RLock()
	defer fake.setupNetworkingMutex.RUnlock()
	return len(fake.setupNetworkingArgsForCall)
}

func (fake *FakePlatform) SetupNetworkingCalls(stub func(settings.Networks, string) error) {
	fake.setupNetworkingMutex.Lock()
	defer fake.setupNetworkingMutex.Unlock()
	fake.SetupNetworkingStub = stub
}

func (fake *FakePlatform) SetupNetworkingArgsForCall(i int) (settings.Networks, string) {
	fake.setupNetworkingMutex.RLock()
	defer fake.setupNetworkingMutex.RUnlock()
	argsForCall := fake.setupNetworkingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) SetupNetworkingReturns(result1 error) {
	fake.setupNetworkingMutex.Lock()
	defer fake.setupNetworkingMutex.Unlock()
	fake.SetupNetworkingStub = nil
	fake.setupNetworkingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupNetworkingReturnsOnCall(i int, result1 error) {
	fake.setupNetworkingMutex.Lock()
	defer fake.setupNetworkingMutex.Unlock()
	fake.SetupNetworkingStub = nil
	if fake.setupNetworkingReturnsOnCall == nil {
		fake.setupNetworkingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupNetworkingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupOptDir() error {
	fake.setupOptDirMutex.Lock()
	ret, specificReturn := fake.setupOptDirReturnsOnCall[len(fake.setupOptDirArgsForCall)]
	fake.setupOptDirArgsForCall = append(fake.setupOptDirArgsForCall, struct {
	}{})
	stub := fake.SetupOptDirStub
	fakeReturns := fake.setupOptDirReturns
	fake.recordInvocation("SetupOptDir", []interface{}{})
	fake.setupOptDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupOptDirCallCount() int {
	fake.setupOptDirMutex.RLock()
	defer fake.setupOptDirMutex.RUnlock()
	return len(fake.setupOptDirArgsForCall)
}

func (fake *FakePlatform) SetupOptDirCalls(stub func() error) {
	fake.setupOptDirMutex.Lock()
	defer fake.setupOptDirMutex.Unlock()
	fake.SetupOptDirStub = stub
}

func (fake *FakePlatform) SetupOptDirReturns(result1 error) {
	fake.setupOptDirMutex.Lock()
	defer fake.setupOptDirMutex.Unlock()
	fake.SetupOptDirStub = nil
	fake.setupOptDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupOptDirReturnsOnCall(i int, result1 error) {
	fake.setupOptDirMutex.Lock()
	defer fake.setupOptDirMutex.Unlock()
	fake.SetupOptDirStub = nil
	if fake.setupOptDirReturnsOnCall == nil {
		fake.setupOptDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupOptDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupRawEphemeralDisks(arg1 []settings.DiskSettings) error {
	var arg1Copy []settings.DiskSettings
	if arg1 != nil {
		arg1Copy = make([]settings.DiskSettings, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setupRawEphemeralDisksMutex.Lock()
	ret, specificReturn := fake.setupRawEphemeralDisksReturnsOnCall[len(fake.setupRawEphemeralDisksArgsForCall)]
	fake.setupRawEphemeralDisksArgsForCall = append(fake.setupRawEphemeralDisksArgsForCall, struct {
		arg1 []settings.DiskSettings
	}{arg1Copy})
	stub := fake.SetupRawEphemeralDisksStub
	fakeReturns := fake.setupRawEphemeralDisksReturns
	fake.recordInvocation("SetupRawEphemeralDisks", []interface{}{arg1Copy})
	fake.setupRawEphemeralDisksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupRawEphemeralDisksCallCount() int {
	fake.setupRawEphemeralDisksMutex.RLock()
	defer fake.setupRawEphemeralDisksMutex.RUnlock()
	return len(fake.setupRawEphemeralDisksArgsForCall)
}

func (fake *FakePlatform) SetupRawEphemeralDisksCalls(stub func([]settings.DiskSettings) error) {
	fake.setupRawEphemeralDisksMutex.Lock()
	defer fake.setupRawEphemeralDisksMutex.Unlock()
	fake.SetupRawEphemeralDisksStub = stub
}

func (fake *FakePlatform) SetupRawEphemeralDisksArgsForCall(i int) []settings.DiskSettings {
	fake.setupRawEphemeralDisksMutex.RLock()
	defer fake.setupRawEphemeralDisksMutex.RUnlock()
	argsForCall := fake.setupRawEphemeralDisksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) SetupRawEphemeralDisksReturns(result1 error) {
	fake.setupRawEphemeralDisksMutex.Lock()
	defer fake.setupRawEphemeralDisksMutex.Unlock()
	fake.SetupRawEphemeralDisksStub = nil
	fake.setupRawEphemeralDisksReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupRawEphemeralDisksReturnsOnCall(i int, result1 error) {
	fake.setupRawEphemeralDisksMutex.Lock()
	defer fake.setupRawEphemeralDisksMutex.Unlock()
	fake.SetupRawEphemeralDisksStub = nil
	if fake.setupRawEphemeralDisksReturnsOnCall == nil {
		fake.setupRawEphemeralDisksReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupRawEphemeralDisksReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupRecordsJSONPermission(arg1 string) error {
	fake.setupRecordsJSONPermissionMutex.Lock()
	ret, specificReturn := fake.setupRecordsJSONPermissionReturnsOnCall[len(fake.setupRecordsJSONPermissionArgsForCall)]
	fake.setupRecordsJSONPermissionArgsForCall = append(fake.setupRecordsJSONPermissionArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetupRecordsJSONPermissionStub
	fakeReturns := fake.setupRecordsJSONPermissionReturns
	fake.recordInvocation("SetupRecordsJSONPermission", []interface{}{arg1})
	fake.setupRecordsJSONPermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupRecordsJSONPermissionCallCount() int {
	fake.setupRecordsJSONPermissionMutex.RLock()
	defer fake.setupRecordsJSONPermissionMutex.RUnlock()
	return len(fake.setupRecordsJSONPermissionArgsForCall)
}

func (fake *FakePlatform) SetupRecordsJSONPermissionCalls(stub func(string) error) {
	fake.setupRecordsJSONPermissionMutex.Lock()
	defer fake.setupRecordsJSONPermissionMutex.Unlock()
	fake.SetupRecordsJSONPermissionStub = stub
}

func (fake *FakePlatform) SetupRecordsJSONPermissionArgsForCall(i int) string {
	fake.setupRecordsJSONPermissionMutex.RLock()
	defer fake.setupRecordsJSONPermissionMutex.RUnlock()
	argsForCall := fake.setupRecordsJSONPermissionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) SetupRecordsJSONPermissionReturns(result1 error) {
	fake.setupRecordsJSONPermissionMutex.Lock()
	defer fake.setupRecordsJSONPermissionMutex.Unlock()
	fake.SetupRecordsJSONPermissionStub = nil
	fake.setupRecordsJSONPermissionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupRecordsJSONPermissionReturnsOnCall(i int, result1 error) {
	fake.setupRecordsJSONPermissionMutex.Lock()
	defer fake.setupRecordsJSONPermissionMutex.Unlock()
	fake.SetupRecordsJSONPermissionStub = nil
	if fake.setupRecordsJSONPermissionReturnsOnCall == nil {
		fake.setupRecordsJSONPermissionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupRecordsJSONPermissionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupRootDisk(arg1 string) error {
	fake.setupRootDiskMutex.Lock()
	ret, specificReturn := fake.setupRootDiskReturnsOnCall[len(fake.setupRootDiskArgsForCall)]
	fake.setupRootDiskArgsForCall = append(fake.setupRootDiskArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetupRootDiskStub
	fakeReturns := fake.setupRootDiskReturns
	fake.recordInvocation("SetupRootDisk", []interface{}{arg1})
	fake.setupRootDiskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupRootDiskCallCount() int {
	fake.setupRootDiskMutex.RLock()
	defer fake.setupRootDiskMutex.RUnlock()
	return len(fake.setupRootDiskArgsForCall)
}

func (fake *FakePlatform) SetupRootDiskCalls(stub func(string) error) {
	fake.setupRootDiskMutex.Lock()
	defer fake.setupRootDiskMutex.Unlock()
	fake.SetupRootDiskStub = stub
}

func (fake *FakePlatform) SetupRootDiskArgsForCall(i int) string {
	fake.setupRootDiskMutex.RLock()
	defer fake.setupRootDiskMutex.RUnlock()
	argsForCall := fake.setupRootDiskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) SetupRootDiskReturns(result1 error) {
	fake.setupRootDiskMutex.Lock()
	defer fake.setupRootDiskMutex.Unlock()
	fake.SetupRootDiskStub = nil
	fake.setupRootDiskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupRootDiskReturnsOnCall(i int, result1 error) {
	fake.setupRootDiskMutex.Lock()
	defer fake.setupRootDiskMutex.Unlock()
	fake.SetupRootDiskStub = nil
	if fake.setupRootDiskReturnsOnCall == nil {
		fake.setupRootDiskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupRootDiskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupRuntimeConfiguration() error {
	fake.setupRuntimeConfigurationMutex.Lock()
	ret, specificReturn := fake.setupRuntimeConfigurationReturnsOnCall[len(fake.setupRuntimeConfigurationArgsForCall)]
	fake.setupRuntimeConfigurationArgsForCall = append(fake.setupRuntimeConfigurationArgsForCall, struct {
	}{})
	stub := fake.SetupRuntimeConfigurationStub
	fakeReturns := fake.setupRuntimeConfigurationReturns
	fake.recordInvocation("SetupRuntimeConfiguration", []interface{}{})
	fake.setupRuntimeConfigurationMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupRuntimeConfigurationCallCount() int {
	fake.setupRuntimeConfigurationMutex.RLock()
	defer fake.setupRuntimeConfigurationMutex.RUnlock()
	return len(fake.setupRuntimeConfigurationArgsForCall)
}

func (fake *FakePlatform) SetupRuntimeConfigurationCalls(stub func() error) {
	fake.setupRuntimeConfigurationMutex.Lock()
	defer fake.setupRuntimeConfigurationMutex.Unlock()
	fake.SetupRuntimeConfigurationStub = stub
}

func (fake *FakePlatform) SetupRuntimeConfigurationReturns(result1 error) {
	fake.setupRuntimeConfigurationMutex.Lock()
	defer fake.setupRuntimeConfigurationMutex.Unlock()
	fake.SetupRuntimeConfigurationStub = nil
	fake.setupRuntimeConfigurationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupRuntimeConfigurationReturnsOnCall(i int, result1 error) {
	fake.setupRuntimeConfigurationMutex.Lock()
	defer fake.setupRuntimeConfigurationMutex.Unlock()
	fake.SetupRuntimeConfigurationStub = nil
	if fake.setupRuntimeConfigurationReturnsOnCall == nil {
		fake.setupRuntimeConfigurationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupRuntimeConfigurationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupSSH(arg1 []string, arg2 string) error {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setupSSHMutex.Lock()
	ret, specificReturn := fake.setupSSHReturnsOnCall[len(fake.setupSSHArgsForCall)]
	fake.setupSSHArgsForCall = append(fake.setupSSHArgsForCall, struct {
		arg1 []string
		arg2 string
	}{arg1Copy, arg2})
	stub := fake.SetupSSHStub
	fakeReturns := fake.setupSSHReturns
	fake.recordInvocation("SetupSSH", []interface{}{arg1Copy, arg2})
	fake.setupSSHMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupSSHCallCount() int {
	fake.setupSSHMutex.RLock()
	defer fake.setupSSHMutex.RUnlock()
	return len(fake.setupSSHArgsForCall)
}

func (fake *FakePlatform) SetupSSHCalls(stub func([]string, string) error) {
	fake.setupSSHMutex.Lock()
	defer fake.setupSSHMutex.Unlock()
	fake.SetupSSHStub = stub
}

func (fake *FakePlatform) SetupSSHArgsForCall(i int) ([]string, string) {
	fake.setupSSHMutex.RLock()
	defer fake.setupSSHMutex.RUnlock()
	argsForCall := fake.setupSSHArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePlatform) SetupSSHReturns(result1 error) {
	fake.setupSSHMutex.Lock()
	defer fake.setupSSHMutex.Unlock()
	fake.SetupSSHStub = nil
	fake.setupSSHReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupSSHReturnsOnCall(i int, result1 error) {
	fake.setupSSHMutex.Lock()
	defer fake.setupSSHMutex.Unlock()
	fake.SetupSSHStub = nil
	if fake.setupSSHReturnsOnCall == nil {
		fake.setupSSHReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupSSHReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupSharedMemory() error {
	fake.setupSharedMemoryMutex.Lock()
	ret, specificReturn := fake.setupSharedMemoryReturnsOnCall[len(fake.setupSharedMemoryArgsForCall)]
	fake.setupSharedMemoryArgsForCall = append(fake.setupSharedMemoryArgsForCall, struct {
	}{})
	stub := fake.SetupSharedMemoryStub
	fakeReturns := fake.setupSharedMemoryReturns
	fake.recordInvocation("SetupSharedMemory", []interface{}{})
	fake.setupSharedMemoryMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupSharedMemoryCallCount() int {
	fake.setupSharedMemoryMutex.RLock()
	defer fake.setupSharedMemoryMutex.RUnlock()
	return len(fake.setupSharedMemoryArgsForCall)
}

func (fake *FakePlatform) SetupSharedMemoryCalls(stub func() error) {
	fake.setupSharedMemoryMutex.Lock()
	defer fake.setupSharedMemoryMutex.Unlock()
	fake.SetupSharedMemoryStub = stub
}

func (fake *FakePlatform) SetupSharedMemoryReturns(result1 error) {
	fake.setupSharedMemoryMutex.Lock()
	defer fake.setupSharedMemoryMutex.Unlock()
	fake.SetupSharedMemoryStub = nil
	fake.setupSharedMemoryReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupSharedMemoryReturnsOnCall(i int, result1 error) {
	fake.setupSharedMemoryMutex.Lock()
	defer fake.setupSharedMemoryMutex.Unlock()
	fake.SetupSharedMemoryStub = nil
	if fake.setupSharedMemoryReturnsOnCall == nil {
		fake.setupSharedMemoryReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupSharedMemoryReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupTmpDir() error {
	fake.setupTmpDirMutex.Lock()
	ret, specificReturn := fake.setupTmpDirReturnsOnCall[len(fake.setupTmpDirArgsForCall)]
	fake.setupTmpDirArgsForCall = append(fake.setupTmpDirArgsForCall, struct {
	}{})
	stub := fake.SetupTmpDirStub
	fakeReturns := fake.setupTmpDirReturns
	fake.recordInvocation("SetupTmpDir", []interface{}{})
	fake.setupTmpDirMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) SetupTmpDirCallCount() int {
	fake.setupTmpDirMutex.RLock()
	defer fake.setupTmpDirMutex.RUnlock()
	return len(fake.setupTmpDirArgsForCall)
}

func (fake *FakePlatform) SetupTmpDirCalls(stub func() error) {
	fake.setupTmpDirMutex.Lock()
	defer fake.setupTmpDirMutex.Unlock()
	fake.SetupTmpDirStub = stub
}

func (fake *FakePlatform) SetupTmpDirReturns(result1 error) {
	fake.setupTmpDirMutex.Lock()
	defer fake.setupTmpDirMutex.Unlock()
	fake.SetupTmpDirStub = nil
	fake.setupTmpDirReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) SetupTmpDirReturnsOnCall(i int, result1 error) {
	fake.setupTmpDirMutex.Lock()
	defer fake.setupTmpDirMutex.Unlock()
	fake.SetupTmpDirStub = nil
	if fake.setupTmpDirReturnsOnCall == nil {
		fake.setupTmpDirReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.setupTmpDirReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) Shutdown() error {
	fake.shutdownMutex.Lock()
	ret, specificReturn := fake.shutdownReturnsOnCall[len(fake.shutdownArgsForCall)]
	fake.shutdownArgsForCall = append(fake.shutdownArgsForCall, struct {
	}{})
	stub := fake.ShutdownStub
	fakeReturns := fake.shutdownReturns
	fake.recordInvocation("Shutdown", []interface{}{})
	fake.shutdownMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) ShutdownCallCount() int {
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	return len(fake.shutdownArgsForCall)
}

func (fake *FakePlatform) ShutdownCalls(stub func() error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = stub
}

func (fake *FakePlatform) ShutdownReturns(result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	fake.shutdownReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) ShutdownReturnsOnCall(i int, result1 error) {
	fake.shutdownMutex.Lock()
	defer fake.shutdownMutex.Unlock()
	fake.ShutdownStub = nil
	if fake.shutdownReturnsOnCall == nil {
		fake.shutdownReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.shutdownReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) StartMonit() error {
	fake.startMonitMutex.Lock()
	ret, specificReturn := fake.startMonitReturnsOnCall[len(fake.startMonitArgsForCall)]
	fake.startMonitArgsForCall = append(fake.startMonitArgsForCall, struct {
	}{})
	stub := fake.StartMonitStub
	fakeReturns := fake.startMonitReturns
	fake.recordInvocation("StartMonit", []interface{}{})
	fake.startMonitMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePlatform) StartMonitCallCount() int {
	fake.startMonitMutex.RLock()
	defer fake.startMonitMutex.RUnlock()
	return len(fake.startMonitArgsForCall)
}

func (fake *FakePlatform) StartMonitCalls(stub func() error) {
	fake.startMonitMutex.Lock()
	defer fake.startMonitMutex.Unlock()
	fake.StartMonitStub = stub
}

func (fake *FakePlatform) StartMonitReturns(result1 error) {
	fake.startMonitMutex.Lock()
	defer fake.startMonitMutex.Unlock()
	fake.StartMonitStub = nil
	fake.startMonitReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) StartMonitReturnsOnCall(i int, result1 error) {
	fake.startMonitMutex.Lock()
	defer fake.startMonitMutex.Unlock()
	fake.StartMonitStub = nil
	if fake.startMonitReturnsOnCall == nil {
		fake.startMonitReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startMonitReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePlatform) UnmountPersistentDisk(arg1 settings.DiskSettings) (bool, error) {
	fake.unmountPersistentDiskMutex.Lock()
	ret, specificReturn := fake.unmountPersistentDiskReturnsOnCall[len(fake.unmountPersistentDiskArgsForCall)]
	fake.unmountPersistentDiskArgsForCall = append(fake.unmountPersistentDiskArgsForCall, struct {
		arg1 settings.DiskSettings
	}{arg1})
	stub := fake.UnmountPersistentDiskStub
	fakeReturns := fake.unmountPersistentDiskReturns
	fake.recordInvocation("UnmountPersistentDisk", []interface{}{arg1})
	fake.unmountPersistentDiskMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePlatform) UnmountPersistentDiskCallCount() int {
	fake.unmountPersistentDiskMutex.RLock()
	defer fake.unmountPersistentDiskMutex.RUnlock()
	return len(fake.unmountPersistentDiskArgsForCall)
}

func (fake *FakePlatform) UnmountPersistentDiskCalls(stub func(settings.DiskSettings) (bool, error)) {
	fake.unmountPersistentDiskMutex.Lock()
	defer fake.unmountPersistentDiskMutex.Unlock()
	fake.UnmountPersistentDiskStub = stub
}

func (fake *FakePlatform) UnmountPersistentDiskArgsForCall(i int) settings.DiskSettings {
	fake.unmountPersistentDiskMutex.RLock()
	defer fake.unmountPersistentDiskMutex.RUnlock()
	argsForCall := fake.unmountPersistentDiskArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePlatform) UnmountPersistentDiskReturns(result1 bool, result2 error) {
	fake.unmountPersistentDiskMutex.Lock()
	defer fake.unmountPersistentDiskMutex.Unlock()
	fake.UnmountPersistentDiskStub = nil
	fake.unmountPersistentDiskReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) UnmountPersistentDiskReturnsOnCall(i int, result1 bool, result2 error) {
	fake.unmountPersistentDiskMutex.Lock()
	defer fake.unmountPersistentDiskMutex.Unlock()
	fake.UnmountPersistentDiskStub = nil
	if fake.unmountPersistentDiskReturnsOnCall == nil {
		fake.unmountPersistentDiskReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.unmountPersistentDiskReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakePlatform) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.addUserToGroupsMutex.RLock()
	defer fake.addUserToGroupsMutex.RUnlock()
	fake.adjustPersistentDiskPartitioningMutex.RLock()
	defer fake.adjustPersistentDiskPartitioningMutex.RUnlock()
	fake.associateDiskMutex.RLock()
	defer fake.associateDiskMutex.RUnlock()
	fake.createUserMutex.RLock()
	defer fake.createUserMutex.RUnlock()
	fake.deleteARPEntryWithIPMutex.RLock()
	defer fake.deleteARPEntryWithIPMutex.RUnlock()
	fake.deleteEphemeralUsersMatchingMutex.RLock()
	defer fake.deleteEphemeralUsersMatchingMutex.RUnlock()
	fake.getAgentSettingsPathMutex.RLock()
	defer fake.getAgentSettingsPathMutex.RUnlock()
	fake.getAuditLoggerMutex.RLock()
	defer fake.getAuditLoggerMutex.RUnlock()
	fake.getCertManagerMutex.RLock()
	defer fake.getCertManagerMutex.RUnlock()
	fake.getCompressorMutex.RLock()
	defer fake.getCompressorMutex.RUnlock()
	fake.getConfiguredNetworkInterfacesMutex.RLock()
	defer fake.getConfiguredNetworkInterfacesMutex.RUnlock()
	fake.getCopierMutex.RLock()
	defer fake.getCopierMutex.RUnlock()
	fake.getDefaultNetworkMutex.RLock()
	defer fake.getDefaultNetworkMutex.RUnlock()
	fake.getDevicePathResolverMutex.RLock()
	defer fake.getDevicePathResolverMutex.RUnlock()
	fake.getDirProviderMutex.RLock()
	defer fake.getDirProviderMutex.RUnlock()
	fake.getEphemeralDiskPathMutex.RLock()
	defer fake.getEphemeralDiskPathMutex.RUnlock()
	fake.getFileContentsFromCDROMMutex.RLock()
	defer fake.getFileContentsFromCDROMMutex.RUnlock()
	fake.getFilesContentsFromDiskMutex.RLock()
	defer fake.getFilesContentsFromDiskMutex.RUnlock()
	fake.getFsMutex.RLock()
	defer fake.getFsMutex.RUnlock()
	fake.getHostPublicKeyMutex.RLock()
	defer fake.getHostPublicKeyMutex.RUnlock()
	fake.getMonitCredentialsMutex.RLock()
	defer fake.getMonitCredentialsMutex.RUnlock()
	fake.getPersistentDiskSettingsPathMutex.RLock()
	defer fake.getPersistentDiskSettingsPathMutex.RUnlock()
	fake.getRunnerMutex.RLock()
	defer fake.getRunnerMutex.RUnlock()
	fake.getUpdateSettingsPathMutex.RLock()
	defer fake.getUpdateSettingsPathMutex.RUnlock()
	fake.getVitalsServiceMutex.RLock()
	defer fake.getVitalsServiceMutex.RUnlock()
	fake.isMountPointMutex.RLock()
	defer fake.isMountPointMutex.RUnlock()
	fake.isPersistentDiskMountableMutex.RLock()
	defer fake.isPersistentDiskMountableMutex.RUnlock()
	fake.isPersistentDiskMountedMutex.RLock()
	defer fake.isPersistentDiskMountedMutex.RUnlock()
	fake.migratePersistentDiskMutex.RLock()
	defer fake.migratePersistentDiskMutex.RUnlock()
	fake.mountPersistentDiskMutex.RLock()
	defer fake.mountPersistentDiskMutex.RUnlock()
	fake.prepareForNetworkingChangeMutex.RLock()
	defer fake.prepareForNetworkingChangeMutex.RUnlock()
	fake.removeDevToolsMutex.RLock()
	defer fake.removeDevToolsMutex.RUnlock()
	fake.removeStaticLibrariesMutex.RLock()
	defer fake.removeStaticLibrariesMutex.RUnlock()
	fake.saveDNSRecordsMutex.RLock()
	defer fake.saveDNSRecordsMutex.RUnlock()
	fake.setTimeWithNtpServersMutex.RLock()
	defer fake.setTimeWithNtpServersMutex.RUnlock()
	fake.setUserPasswordMutex.RLock()
	defer fake.setUserPasswordMutex.RUnlock()
	fake.setupBlobsDirMutex.RLock()
	defer fake.setupBlobsDirMutex.RUnlock()
	fake.setupBoshSettingsDiskMutex.RLock()
	defer fake.setupBoshSettingsDiskMutex.RUnlock()
	fake.setupCanRestartDirMutex.RLock()
	defer fake.setupCanRestartDirMutex.RUnlock()
	fake.setupDataDirMutex.RLock()
	defer fake.setupDataDirMutex.RUnlock()
	fake.setupEphemeralDiskWithPathMutex.RLock()
	defer fake.setupEphemeralDiskWithPathMutex.RUnlock()
	fake.setupHomeDirMutex.RLock()
	defer fake.setupHomeDirMutex.RUnlock()
	fake.setupHostnameMutex.RLock()
	defer fake.setupHostnameMutex.RUnlock()
	fake.setupIPv6Mutex.RLock()
	defer fake.setupIPv6Mutex.RUnlock()
	fake.setupLogDirMutex.RLock()
	defer fake.setupLogDirMutex.RUnlock()
	fake.setupLoggingAndAuditingMutex.RLock()
	defer fake.setupLoggingAndAuditingMutex.RUnlock()
	fake.setupLogrotateMutex.RLock()
	defer fake.setupLogrotateMutex.RUnlock()
	fake.setupMonitUserMutex.RLock()
	defer fake.setupMonitUserMutex.RUnlock()
	fake.setupNetworkingMutex.RLock()
	defer fake.setupNetworkingMutex.RUnlock()
	fake.setupOptDirMutex.RLock()
	defer fake.setupOptDirMutex.RUnlock()
	fake.setupRawEphemeralDisksMutex.RLock()
	defer fake.setupRawEphemeralDisksMutex.RUnlock()
	fake.setupRecordsJSONPermissionMutex.RLock()
	defer fake.setupRecordsJSONPermissionMutex.RUnlock()
	fake.setupRootDiskMutex.RLock()
	defer fake.setupRootDiskMutex.RUnlock()
	fake.setupRuntimeConfigurationMutex.RLock()
	defer fake.setupRuntimeConfigurationMutex.RUnlock()
	fake.setupSSHMutex.RLock()
	defer fake.setupSSHMutex.RUnlock()
	fake.setupSharedMemoryMutex.RLock()
	defer fake.setupSharedMemoryMutex.RUnlock()
	fake.setupTmpDirMutex.RLock()
	defer fake.setupTmpDirMutex.RUnlock()
	fake.shutdownMutex.RLock()
	defer fake.shutdownMutex.RUnlock()
	fake.startMonitMutex.RLock()
	defer fake.startMonitMutex.RUnlock()
	fake.unmountPersistentDiskMutex.RLock()
	defer fake.unmountPersistentDiskMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePlatform) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ platform.Platform = new(FakePlatform)
